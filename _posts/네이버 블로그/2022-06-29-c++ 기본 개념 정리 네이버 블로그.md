---
layout: posts
title: #title
categories: [programming, ]
tag: [c++, 네이버 블로그]  # tag가 추가됨.
toc: true   # 글 오른쪽에 toc가 나온다.
author_profile: false # 글을 누르면 내 소개가 없어짐. true로 하면 얼굴이 나옴.
sidebar:      # 글을 누르면 목차가 나온다.
  nav: "counts" 
search: true     # false라고 하면 글이 검색이 안된다.
---


#c++ 기본 개념 정리 : 네이버 블로그
<div class="wrap_rabbit pcol2 _param(1) _postViewArea222793457388" id="post-view222793457388">
<!-- Rabbit HTML --><div class="se-viewer se-theme-default" lang="ko-KR">
<!-- SE_DOC_HEADER_START -->
<div class="se-component se-documentTitle se-l-default" id="SE-326e2b21-57bb-43fa-a32d-d52f49b45fdc">
<div class="se-component-content">
<div class="se-section se-section-documentTitle se-l-default se-section-align-left">
<!-- -->
<div class="blog2_series">
<a class="pcol2" href="/PostList.naver?blogId=wys000112&amp;categoryNo=15&amp;from=postList" onclick="nclk_v2(this,'pst.category','','');">c++ 정리</a>
</div>
<div class="pcol1">
<!-- -->
<div class="se-module se-module-text se-title-text">
<p class="se-text-paragraph se-text-paragraph-align-" id="SE-5219752b-0f35-4836-80fd-2f6464d0fbcc" style=""><span class="se-fs- se-ff-" id="SE-c39fb095-f766-11ec-b092-d571aa9687fb" style=""><!-- -->c++ 기본 개념 정리<!-- --></span></p> </div>
<!-- -->
</div>
<div class="blog2_container">
<span class="writer">
<span class="area_profile"><a class="link" href="https://blog.naver.com/wys000112" onclick="nclk_v2(this,'pst.profile','','');" target="_top"><img alt="프로파일" class="img" src="https://blogpfthumb-phinf.pstatic.net/MjAyMjA1MjVfMTA0/MDAxNjUzNDcxMTU4NTkw.MKx5XZzKhkVnSwLw5O1NM-J45hdDNIrADB_V9VVQBOAg.OkL09v5VWJCO9xIBu4VTEzVASngUXGDvkf4D_exCZsEg.PNG.wys000112/%EB%AC%B4%EC%A7%80%EC%84%B1.png/%25EB%25AC%25B4%25EC%25A7%2580%25EC%2584%25B1.png?type=s1"/></a></span>
<span class="nick"><a class="link pcol2" href="https://blog.naver.com/wys000112" onclick="nclk_v2(this,'pst.username','','');" target="_top">무지성</a></span>
</span>
<i class="dot"> ・ </i>
<span class="se_publishDate pcol2">2022. 6. 29. 13:27</span>
</div>
<div class="blog2_post_function">
<a class="url pcol2 _setClipboard _returnFalse _se3copybtn _transPosition" href="#" id="copyBtn_222793457388" style="cursor:pointer;" title="https://blog.naver.com/wys000112/222793457388">URL 복사</a>
<a class="btn_buddy btn_addbuddy pcol2 _buddy_popup_btn _returnFalse" href="#" onclick="nclk_v2(this,'pst.addnei','','');"><i class="ico"></i> 이웃추가<i class="aline"></i></a>
<div class="overflow_menu">
<a area-expanded="false" area-haspopup="true" class="btn_overflow_menu _open_overflowmenu pcol2 _param(222793457388) _returnFalse" href="#" role="button"><span class="blind">본문 기타 기능</span></a>
<div area-hidden="true" class="lyr_overflow_menu" id="overflowmenu-222793457388">
<a class="naver-splugin btn_splugin share _title_share" data-canonical-url="https://blog.naver.com/wys000112/222793457388" data-likecontentsid="wys000112_222793457388" data-likeserviceid="BLOG" data-logdomain="https://proxy.blog.naver.com/spi/v1/api/shareLog" data-me-display="off" data-oninitialize="splugin_oninitialize(1);" data-option="{baseElement:'_title_spiButton', layerPosition:'outside-bottom', align:'right', marginLeft:0, marginTop:4}" data-style="unity" data-url="https://blog.naver.com/wys000112/222793457388" href="#" id="_title_spiButton" onclick="return false;">
                   공유하기
                <span class="ico_share _title_share_icon"></span>
</a>
<a class="_report _param(https://srp2.naver.com/report?svc=BLG&amp;exit=close&amp;ctype=AA01&amp;cwriterenc=dEfzIv4Ps9lISogpYgGdS5%2F3EUa7EZ7XlcG7rDCZ2rg%3D&amp;ctitle=c%2B%2B%20%EA%B8%B0%EB%B3%B8%20%EA%B0%9C%EB%85%90%20%EC%A0%95%EB%A6%AC&amp;cwriter=wys0*****&amp;dark=disable&amp;memtype=Y&amp;env=pc&amp;cnickname=wys0*****&amp;vsvc=BLG&amp;cid=wys000112%40%4051896191%40%40mylog%40%40222793457388) _returnFalse" href="#">신고하기<span class="ico_report"></span></a>
</div>
</div>
<input alt="url" class="copyTargetUrl" style="display:none;" title="URL 복사" type="text" value="https://blog.naver.com/wys000112/222793457388"/>
</div>
<!-- -->
</div>
</div>
</div>
<!-- B2C 상품 -->
<!-- _BLOG_CONTENTS_HEADER_TAIL -->
<!-- SE_DOC_HEADER_END -->
<div class="se-main-container">
<div class="se-component se-text se-l-default" id="SE-ab6560b9-d2de-44b8-b9be-c5e1dd2398fd">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<!-- SE-TEXT { --><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ae20477b-ece9-49b8-af00-8dffd4121a4d" style=""><span class="se-fs- se-ff-" id="SE-c39ffeb6-f766-11ec-b092-71707b438d25" style="">c++ 애매한 개념이 너무 많아서 내 입장에서 애매한 기본 개념을 정리하려고 한다.</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e8ff6c60-5b21-43ef-b6f7-0aef67f03e19" style=""><span class="se-fs- se-ff-" id="SE-c39ffeb7-f766-11ec-b092-d33cd93edaf7" style="">책은 fundamentals of C++ programming, 2018, Richard L. Haleterman이다.</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e6631900-a021-4803-a553-7e06d010e182" style=""><span class="se-fs- se-ff-" id="SE-c39ffeb8-f766-11ec-b092-2fb7f618dbd9" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-61e19aca-d459-4dc9-8a60-a3cd7f36e225" style=""><span class="se-fs- se-ff-" id="SE-c39ffeb9-f766-11ec-b092-152d4b0ddf44" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1fcde596-06db-40d6-bc2b-d6ecd01b6d0f" style=""><span class="se-fs- se-ff-" id="SE-c39ffeba-f766-11ec-b092-ed9607e13416" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7f27f5ff-46d2-42fd-b11e-e0743ee54dd4" style=""><span class="se-fs- se-ff-" id="SE-c3a025cb-f766-11ec-b092-31794d23ac36" style="">Ch.1. The context of software development</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1daab58e-3042-460f-86af-d20212aa3a42" style=""><span class="se-fs- se-ff-" id="SE-c3a025cc-f766-11ec-b092-67e5ea996720" style="">프로그래머는 software development process를 향상시키기 위한 다양한 tool들을 사용한다. editor, preprocessor, compiler, linker, debugger, profiler가 있다. preprocessor는 compiler가 code를 process 시키기 전 라이브러리를 include시키는 과정(#include). compiler는 object code로 라이브러리와 editor에서 편집한 소스 코드를 합친다. linker는 compile된 라이브러리 object code를 source code와 연결시키는 작업을 함. 그러면 실행 가능한 프로그램이 작성 됨. profiler는 프로그램 실행에 관한 총계를 수집하여, 개발자로 하여줌 성능향상을 하도록 프로그램을 조정할 수 있게 해준다. profiler는 모든 코드가 실제로 어딘가에서 실행되고 있는지 시험해 볼 수 있는데, 이를 coverage 과정이라고 한다. 즉 profiling은 프로그램 특정 부분을 향상시켜 프로그램이 더 빠르게 실행될 수 있도록 한다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3c227c7b-20ca-413d-86f4-e292ff3cf539" style=""><span class="se-fs- se-ff-" id="SE-c3a025cd-f766-11ec-b092-435e1c40d9ba" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0d7b59f4-4b1a-4b47-894c-c5c1fb5080db" style=""><span class="se-fs- se-ff-" id="SE-c3a025ce-f766-11ec-b092-f38dddef0de7" style="">Ch.3. Values and variables</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-778baba8-101f-47f7-b84b-0fdd7e6cff12" style=""><span class="se-fs- se-ff-" id="SE-c3a025cf-f766-11ec-b092-71219050a929" style="">운영체제에 따라서 '\n'이 carrage return(왼쪽으로 가는 것), line feed(한줄 밑으로 가는 것)으로 나뉜다. windows의 경우 CR LF, linux의 경우 LF가 된다. 그러나 c++에서는 c++ standard에 의해 동일하게 나오도록 보장된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-39d79570-1ce7-470a-bf7f-e4a1359fc166" style=""><span class="se-fs- se-ff-" id="SE-c3a025d0-f766-11ec-b092-fdf083aa374c" style="">한번 변수가 선언되면 재선언될 수 없다. 선언되지 않은 변수 쓰면 에러.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-183cf2fd-aa75-43db-a422-9064c7f2b256" style=""><span class="se-fs- se-ff-" id="SE-c3a04ce1-f766-11ec-b092-57460c1401fe" style="">16진수 표현 방식: OxA9 = 169(숫자 앞에 Ox을 붙임)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1f5e7ca6-2354-4933-900c-26ef603320ce" style=""><span class="se-fs- se-ff-" id="SE-c3a04ce2-f766-11ec-b092-7505b7445487" style="">8진수 표현 방식: 0110 = 72(숫자 앞에 0을 붙임)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5266f112-a108-46bf-9e45-615a4bc4b75d" style=""><span class="se-fs- se-ff-" id="SE-c3a04ce3-f766-11ec-b092-dfeeeaac8a7b" style="">superscript 표현 방식: 6.023 * 10^23 = 6.023e23</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9a8a4249-4bf7-4b89-b47e-a88971131777" style=""><span class="se-fs- se-ff-" id="SE-c3a04ce4-f766-11ec-b092-772ada531b02" style="">float = 10.2F, unsinged long long = 10.43uLL, 특히 long 값은 l이 1과 혼동될 수 있기 때문에 대문자로 쓰는 것이 일반적.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-52ef1283-2bc4-450e-8ded-d8002219d45f" style=""><span class="se-fs- se-ff-" id="SE-c3a04ce5-f766-11ec-b092-0bd2a7d67f5a" style="">자료형의 경우 운영체제에 따라 몇byte가 최대인지 바뀜. 그러나 큰 값이 작은 값보다 최대값이 크거나 같은 것은 확실함.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a2bb4adf-6b51-4502-b842-2dea6eda517a" style=""><span class="se-fs- se-ff-" id="SE-c3a04ce6-f766-11ec-b092-47d7099c7250" style="">enumerated type: enum Color {yellow,red, orange}; Color myColor; myColor = orange; 이런 스타일의 enumerated type definition은 unscoped enumeration이라고 불림.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5697927b-52ce-4b60-83b0-d5b05a62eb1e" style=""><span class="se-fs- se-ff-" id="SE-c3a073f7-f766-11ec-b092-f9ff72998d52" style="">unscoped enumeration이 안좋은 이유는 enum Color {yellow,red, orange}; enum Fruit {banana, orange};를 하게 되면 duplicate enumeration values in different type를 가지는데 이게 오류를 만듬. 따라서 이를 해결하기 위해  scoped enumeration 방식으로 정의되는 enumeration class라는 개념이 나왔음. enumeration class는    enum class Shade { Dark, Dim, Light}; Shade color = Shade::Light; 이런 식으로 ::operator를 사용해서 compiler가 겹치는 두가지 값을 구별할 수 있도록 해준다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5f55f2d3-fbc4-4d82-a24b-7c8db8a548e2" style=""><span class="se-fs- se-ff-" id="SE-c3a073f8-f766-11ec-b092-796b2810025e" style="">auto x;와 같이 선언만 해주면 오류남. 정의가 같이 되어야 함.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-154df292-8eff-4def-b59a-7fc8f05c1ef4" style=""><span class="se-fs- se-ff-" id="SE-c3a073f9-f766-11ec-b092-85d3a2f1edbb" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-66ba113a-751b-4c56-a282-2a63b168aecf" style=""><span class="se-fs- se-ff-" id="SE-c3a09b0a-f766-11ec-b092-c599ebd34696" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-37b8a758-ab2e-4bbe-a70a-f1a1894262f0" style=""><span class="se-fs- se-ff-" id="SE-c3a09b0b-f766-11ec-b092-e9e1128e0caa" style="">Ch.4. Expressions and Arithemetic</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7a85e6c4-bdf5-475a-b09e-694e37b22310" style=""><span class="se-fs- se-ff-" id="SE-c3a09b0c-f766-11ec-b092-090f2d8942cf" style="">double dominates int-truncation: / operator의 오른쪽이나 왼쪽 하나만 double이면 truncation 안 일어남.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9b792e12-37bf-4f88-9d2c-dbc0784dae3c" style=""><span class="se-fs- se-ff-" id="SE-c3a09b0d-f766-11ec-b092-7526f111237d" style="">4.6 Errors and warnings</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d08672bf-192c-44aa-a8fc-ee642d83ccad" style=""><span class="se-fs- se-ff-" id="SE-c3a0c21e-f766-11ec-b092-c5920ce63371" style="">error는 3가지로 이루어져있다. 1) compile-time error 2) run-time error 3) logic error. 1) compile-time error 는 syntax error와 link error로 이루어져 있다. 2) run-time error는 invalid memory access(int인데 사용자가 double형 입력하는것), memory leak(메모리 다 쓰고 반납 안하면 program crash == run-time error)가 있다. 즉 run-time error는 실행은 잘 되는데 내가 원하는 것이 아니라는 오류가 나오는 것이다. 이때 프로그램이 crash 되었다고 한다. run time error의 예는 divide by zero가 있다. logic error은 wrong formula/output, division by zero가 있다. logic error의 특징은 포로그램은 error를 가지고 있지만, compiler나 run-time system이 detect하지 못하는 error다. 즉 잘못된 결과값을 출력하는 프로그램이다. logic error의 예로는 프로그래머가 원래 dividend/divisor라고 써야 하는데 divisor/dividend라고 잘못 쓰는 것이다.</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b509bb60-6826-472d-85a3-be79fcc6f6cd" style=""><span class="se-fs- se-ff-" id="SE-c3a0c21f-f766-11ec-b092-c917e87d7637" style="">초보자는 compile error를 초반에 많이 한다. 그러나 숙달이 될수록 logic error가 늘어난다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b3ccc216-0bbb-4aa0-8688-2d2584b87f16" style=""><span class="se-fs- se-ff-" id="SE-c3a0c220-f766-11ec-b092-cfdc8a264ef2" style="">bug == compiler detection에서 벗어나는 error들인 run-time error와 logic error를 의미한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ecffd3f8-4b03-4f4b-b569-49693d7b355b" style=""><span class="se-fs- se-ff-" id="SE-c3a0c221-f766-11ec-b092-75ea87206ef2" style="">Compiler Warning은 compiler가 C++ 언어 규칙을 지키지 않은 경우 주는 notification이다. 예를 들어 uninitialized object라던지, Narrowing conversion이라던지(double to int). 이럴때는 static_cast&lt;int&gt;를 쓰면 해결되긴 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-faa3752a-2422-4243-b299-aacc71239dbd" style=""><span class="se-fs- se-ff-" id="SE-c3a0c222-f766-11ec-b092-b73b1c2234f7" style="">unsigned tiny는 5bit만 사용하는 (0-31) 자료형이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-22cdc70a-0d6c-4598-a60b-b3c7815028eb" style=""><span class="se-fs- se-ff-" id="SE-c3a0c223-f766-11ec-b092-ffb47496993f" style="">bitwise operator에는 &lt;&lt;와 &gt;&gt;가 있다. &lt;&lt;는 shift left다. &gt;&gt;는 shift right다. 5 &lt;&lt; 2 하면 20된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1061d86e-f5b3-4503-bb2c-5cca97c46e49" style=""><span class="se-fs- se-ff-" id="SE-c3a0c224-f766-11ec-b092-0de3d7e9881e" style="">bitwise operator는 keyboard 동시에 누르는거에 활용될 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b74b1d6c-a329-456e-a264-783ff9b4067a" style=""><span class="se-fs- se-ff-" id="SE-3be2ce19-99db-48d6-96b0-528435c39dcd" style="">c++에서 modulo operator는, quotient가 0을 중심으로 remainder가 형성이 된다. 이게 무슨 말이냐면 remainder-quotient theorem에서, n = dq+r인데, for positive integer d, there is a unique integer q and r s.t. 0 &lt;= r &lt; d 이지 않은가. python의 경우 이 theorem이 적용이 되는데, c++의 경우 q가 0 쪽으로 형성이 된다. 즉 q가 음수이면 r이 음수가 된다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-eb1b51ea-9fd7-40c6-a7b2-ba64869053d8" style=""><span class="se-fs- se-ff-" id="SE-c3a0e935-f766-11ec-b092-8db4471bc6f3" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-6c9982d8-4eec-48ce-b89e-fd5a69995f3b" style=""><span class="se-fs- se-ff-" id="SE-c3a0e936-f766-11ec-b092-9b222734e19f" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-695ee647-a675-4339-94e3-d28bca637bef" style=""><span class="se-fs- se-ff-" id="SE-c3a0e937-f766-11ec-b092-e5f5ea04f53b" style="">Ch.5. Conditional Execution</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d2f4f1f5-41c7-4e1d-8bb1-28431f011592" style=""><span class="se-fs- se-ff-" id="SE-c3a0e938-f766-11ec-b092-2ff803d95756" style="">operator precedence: 1. scope resolution 2. a++, a--, a[], static_cast&lt;int&gt;, reinterpret_cast&lt;int *&gt;, ., -&gt; 3.(right to left associativity) --a ++a, &amp;p *p, -a +a, !,~, new delete, (int), sizeof 4. * / % 5. + - 6. &gt;&gt; &lt;&lt; 7. &lt; &lt;= &gt; &gt;= 8. == != 9. &amp; 10. ^ 11. | 12. &amp;&amp; 13. || 14. (right to left associativity) ?: assignment(=) compound assignments &gt;&gt;= |= +=</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e0bc1176-872f-497b-b6cb-b3d87d21c5bd" style=""><span class="se-fs- se-ff-" id="SE-b23514c2-7a33-4f23-a910-5da7b4e579f8" style="">a++, a[], *a, ++a에서 right to left associativity보다 우선순위가 높고, a가 왼쪽에서 나오면 left to right associativity 이고, ++a 처럼 a가 오른쪽에서 나오면 right to left associativity 이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4a39dd11-4194-408f-aa27-d1be7c5d40aa" style=""><span class="se-fs- se-ff-" id="SE-c4684659-1539-4e1c-a555-03e55101b2af" style="">보통 left to right associativity가 right to left associativity보다 우선순위가 높다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-8a50e849-de78-448d-b98d-fecaf261f6bb" style=""><span class="se-fs- se-ff-" id="SE-41fc8886-9ca9-4b7c-9fff-3093dd626ea6" style="">복잡한 구문의 operator precedence를 판단할 때에는 clockwise/Spiral Rule을 사용한다. 자세한 내용은 링크 참조.(</span><span class="se-fs- se-ff-" id="SE-c572568c-3bb2-4de2-bf58-d5379e0a919d" style=""><a class="se-link" href="https://stackoverflow.com/questions/24685173/how-are-complex-declarations-parsed-in-terms-of-precedence-and-associativity" target="_blank">https://stackoverflow.com/questions/24685173/how-are-complex-declarations-parsed-in-terms-of-precedence-and-associativity</a></span><span class="se-fs- se-ff-" id="SE-05611792-a95e-485d-b9a9-ddfeeaaa7186" style="">) (</span><span class="se-fs- se-ff-" id="SE-bfdb4e84-6b0b-4d83-b40f-354e2d58e6b2" style=""><a class="se-link" href="https://c-faq.com/decl/spiral.anderson.html" target="_blank">https://c-faq.com/decl/spiral.anderson.html</a></span><span class="se-fs- se-ff-" id="SE-e789ecea-55a3-4afb-a7b1-9939cfe0c7ca" style="">)</span></p></li></ul><!-- } SE-TEXT -->
</div>
</div>
</div>
</div> <div class="se-component se-oglink se-l-text" id="SE-88535245-8eb1-4de1-aa17-eaf2e31a5783">
<div class="se-component-content">
<div class="se-section se-section-oglink se-l-text se-section-align-left">
<div class="se-module se-module-oglink">
<a class="se-oglink-info" href="https://c-faq.com/decl/spiral.anderson.html" target="_blank">
<div class="se-oglink-info-container">
<strong class="se-oglink-title">Clockwise/Spiral Rule</strong>
<p class="se-oglink-summary">[This was posted to comp.lang.c by its author, David Anderson, on 1994-05-06.] The ``Clockwise/Spiral Rule'' By David Anderson There is a technique known as the ``Clockwise/Spiral Rule'' which enables any C programmer to parse in their head any C declaration! There are three simple steps to follow: ...</p>
<p class="se-oglink-url">c-faq.com</p>
</div>
</a>
</div>
</div>
</div>
<script class="__se_module_data" data-module='{"type":"v2_oglink", "id" :"SE-88535245-8eb1-4de1-aa17-eaf2e31a5783", "data" : {"link" : "https://c-faq.com/decl/spiral.anderson.html", "isVideo" : "false", "thumbnail" : ""}}' type="text/data"></script>
</div> <div class="se-component se-text se-l-default" id="SE-334b4474-63d2-4fcb-b9e7-80a569b62225">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<!-- SE-TEXT { --><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4610cc9a-d2f5-4b5e-bb31-4e63e1d38272" style=""><span class="se-fs- se-ff-" id="SE-c3a0e93a-f766-11ec-b092-952a6f3dce9c" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-44dea930-3f2e-4fa2-96e3-3867f9e126a5" style=""><span class="se-fs- se-ff-" id="SE-c3a0e93b-f766-11ec-b092-d5041d9c51f2" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1372c37e-ab1c-42fc-9933-f9cbf6355153" style=""><span class="se-fs- se-ff-" id="SE-c3a0e93c-f766-11ec-b092-335ecb50c30b" style="">Ch.6. Iteration</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-22647bad-f6ee-4634-b921-fc6ea3a7d123" style=""><span class="se-fs- se-ff-" id="SE-c3a1104d-f766-11ec-b092-5977b82da435" style=""><span class="__se-hash-tag">#include</span> &lt;iomanip&gt;:  std::cout &lt;&lt; std::setw(10) &lt;&lt; x &lt;&lt; '\n'; -&gt; 오른쪽 정렬</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ae96da38-d55b-446c-9065-4350f402c03b" style=""><span class="se-fs- se-ff-" id="SE-c3a1104e-f766-11ec-b092-5d056d37d480" style=""><span class="__se-hash-tag">#include</span> &lt;locale&gt;: std::cout.imbue(std::locale("")); std::cout &lt;&lt; std::setw(13) &lt;&lt; x; -&gt; 3자리마다 컴마 생김.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1ba5fe78-3f32-4b16-8828-b60dcda03276" style=""><span class="se-fs- se-ff-" id="SE-c3a1104f-f766-11ec-b092-95ba59d9d46f" style="">break,continue는 for/while loop에 적용 가능. break는 loop을 바로 나감. continue는 for loop의 경우에는 modification 부분에 가고 while의 경우에는 조건 검사하는 곳으로 감. 그러나 break나 continue는 if-else문으로 대체가 가능하긴 하다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-410731bd-d271-445e-8fe6-d51fcf380652" style=""><span class="se-fs- se-ff-" id="SE-c3a11050-f766-11ec-b092-37fb5c3da2aa" style="">goto end;하면, int main() 함수 안에 end:라고 특정 위치를 지정해 주어야 함.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-dc384ab7-eda1-44da-8e59-33bc2da2d5f8" style=""><span class="se-fs- se-ff-" id="SE-c3a11051-f766-11ec-b092-b5793236a5ef" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-eacceca4-cb02-4b5c-bd36-288adbe7d442" style=""><span class="se-fs- se-ff-" id="SE-c3a11052-f766-11ec-b092-61f31ae53cd6" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1f5daffb-d9e4-473b-b9b9-5d00745d93c3" style=""><span class="se-fs- se-ff-" id="SE-c3a11053-f766-11ec-b092-27c4a127b4e6" style="">Ch.7. Other Conditional and Iterative Statements</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a249e286-43b8-4ad7-89ee-2a86d0c562ac" style=""><span class="se-fs- se-ff-" id="SE-c3a11054-f766-11ec-b092-b542fcab5d83" style="">switch statement는</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-31fd491a-47ff-48ff-a57a-21a531944d07" style=""><span class="se-fs- se-ff-" id="SE-c3a13765-f766-11ec-b092-1558d94b6b6d" style="">switch (value) {</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-976dbe64-3680-4c69-b003-6f676afb36f7" style=""><span class="se-fs- se-ff-" id="SE-c3a13766-f766-11ec-b092-1f06ab94f890" style="">case 1:</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-60d552de-038f-4b79-9ce6-624c90538a57" style=""><span class="se-fs- se-ff-" id="SE-c3a13767-f766-11ec-b092-6598c2bfd5e1" style="">    std::cout &lt;&lt; "1";</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-68cb1a5b-5097-44dd-93c1-b6ea6a068c7d" style=""><span class="se-fs- se-ff-" id="SE-c3a13768-f766-11ec-b092-8b9f6416793b" style="">    break;</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ef25a858-c804-463d-8b80-add4da12c182" style=""><span class="se-fs- se-ff-" id="SE-c3a13769-f766-11ec-b092-392097f9e012" style="">case 2:</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-00c98c0a-8f65-4eae-a4aa-909bead743ae" style=""><span class="se-fs- se-ff-" id="SE-c3a1376a-f766-11ec-b092-916ee346eb57" style="">    std::cout &lt;&lt; "2";</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f2bef0aa-9b3f-42dd-a6e8-f0662d1f39a6" style=""><span class="se-fs- se-ff-" id="SE-c3a1376b-f766-11ec-b092-5353c95fc922" style="">    break;</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c391ff9e-696e-48c2-9244-babecd70b8bb" style=""><span class="se-fs- se-ff-" id="SE-c3a1376c-f766-11ec-b092-e796abd16acd" style="">default:</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-646d29f4-6125-4a3a-998a-aadd5edd93cf" style=""><span class="se-fs- se-ff-" id="SE-c3a15e7d-f766-11ec-b092-0f90f79d0766" style="">    std::cout &lt;&lt; "3";</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c8af7d29-6cee-4aed-b8c0-c385c380e933" style=""><span class="se-fs- se-ff-" id="SE-c3a15e7e-f766-11ec-b092-c5d7154de56f" style="">}</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9c97306e-be49-46b2-b573-9bf50f263434" style=""><span class="se-fs- se-ff-" id="SE-c3a15e7f-f766-11ec-b092-797aa086756c" style="">형태로 표현 가능하다.</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e8708ccf-0739-45b4-8c53-b1f623ab3266" style=""><span class="se-fs- se-ff-" id="SE-c3a15e80-f766-11ec-b092-bda03c296552" style="">for(;;) 형태로도 사용 가능하다. 이때 초기화는 loop 밖에서 해줘야 하고, 조건의 경우 break나 goto를 반드시 사용해야 하고, modification은 loop 내부에서 해줘야 한다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f26f88b3-7d32-4035-bde6-44c8e70793b2" style=""><span class="se-fs- se-ff-" id="SE-c3a15e81-f766-11ec-b092-41db9f965184" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0469046f-8bd0-4e5b-a03d-f2b59bea0c53" style=""><span class="se-fs- se-ff-" id="SE-c3a15e82-f766-11ec-b092-47b7e1bdf756" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ce1e6fa4-4a8e-4c6e-b52c-6d03a2748bcd" style=""><span class="se-fs- se-ff-" id="SE-c3a15e83-f766-11ec-b092-c56ac4dc3afe" style="">Ch.8. Using functions</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4a3ef64b-97cd-488e-8724-59082f5af374" style=""><span class="se-fs- se-ff-" id="SE-c3a15e84-f766-11ec-b092-f31a0dab1a25" style=""><span class="__se-hash-tag">#include</span> &lt;cmath&gt;: parameter, return값 다 double인 함수: sqrt,exp,log,log10,cos, pow(2,2),fabs</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f397785b-1c04-4ce6-9530-4eb0074786f6" style=""><span class="se-fs- se-ff-" id="SE-c3a15e85-f766-11ec-b092-fbbf5d8da454" style=""><span class="__se-hash-tag">#include</span> &lt;algorithm&gt;: std::max(value1,value2), std::min(value1,value2)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b8fa32e8-12cf-402d-9130-ac792d27a4fa" style=""><span class="se-fs- se-ff-" id="SE-c3a18596-f766-11ec-b092-f9ac63bded3f" style=""><span class="__se-hash-tag">#include</span> &lt;ctime&gt;: // elapsed time 구하는 방법</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-414b500f-a2bf-4df2-abf4-f7b2450ad5cf" style=""><span class="se-fs- se-ff-" id="SE-c3a18597-f766-11ec-b092-ffc066dde4a6" style="">clock_t timeNowInMilliSec1 = clock();</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d6c1f93c-895e-4e9a-a782-957b4b196d01" style=""><span class="se-fs- se-ff-" id="SE-c3a18598-f766-11ec-b092-d50734bdffda" style="">std::cin &gt;&gt; a; </span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-56dff2e7-0100-40b0-8331-78777eae92af" style=""><span class="se-fs- se-ff-" id="SE-c3a18599-f766-11ec-b092-e1f2a57e9f99" style="">clock_t timeNowInMilliSec2 = clock(); // (clock_t = unsigned long)</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-eab6d483-f859-4ba1-8201-35ca83e08ee3" style=""><span class="se-fs- se-ff-" id="SE-c3a1859a-f766-11ec-b092-3b3363747bda" style="">double elapsedTime = static_cast&lt;double&gt;(timeNowInMilliSec2 - timeNowInMilliSec1) / CLOCKS_PER_SEC(1000); //elapsed time </span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3a7296f4-d0a6-4897-b648-69c4b7dc3c8e" style=""><span class="se-fs- se-ff-" id="SE-c3a1859b-f766-11ec-b092-b374fe1a941b" style=""><span class="__se-hash-tag">#include</span> &lt;cctype&gt; parameter, return값 모두 int인 함수: toupper, tolower, isupper, islower, isalpha, isdigit</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-8c6edb07-1355-4286-8621-cfdfdba6ce6e" style=""><span class="se-fs- se-ff-" id="SE-c3a1859c-f766-11ec-b092-457ce606167a" style=""><span class="__se-hash-tag">#include</span> &lt;cstdlib&gt;: // random number generation</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-31132d29-5ac4-4089-97a1-d3935bd439b3" style=""><span class="se-fs- se-ff-" id="SE-c3a1859d-f766-11ec-b092-612c2ade817a" style="">srand(static_cast&lt;unsigned&gt;(time(0)));</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-da8034b9-abac-4d5b-84b4-427332ec61a2" style=""><span class="se-fs- se-ff-" id="SE-c3a1acae-f766-11ec-b092-cb1fd46ecab9" style="">int r = rand() % 100 + 1; // 1-100 범위의 정수.</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2332a3e4-fd52-4c30-abc8-24fceeda9e3a" style=""><span class="se-fs- se-ff-" id="SE-c3a1acaf-f766-11ec-b092-9def8c0248ab" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-44affd4c-0ae8-4184-9b28-1c2a19db3d9c" style=""><span class="se-fs- se-ff-" id="SE-c3a1acb0-f766-11ec-b092-158d444f403d" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-521ed32f-48ba-460f-a71e-3f2f3361442d" style=""><span class="se-fs- se-ff-" id="SE-c3a1acb1-f766-11ec-b092-753b67038d0c" style="">Ch.9. Writing functions</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d43dc734-8f44-4417-80e5-29c22ae972f1" style=""><span class="se-fs- se-ff-" id="SE-c3a1acb2-f766-11ec-b092-bdb5311cd698" style="">pass by value: 서로 복사하는 변수 두개의 주소값이 다르다. 따라서 복사 이후 변수들은 서로 연결되지 않는다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ee745f38-dab0-4c6d-b6f5-87f4f44b6d83" style=""><span class="se-fs- se-ff-" id="SE-fffa49a7-1051-4c61-a35e-fdf4a1ac2965" style="">pass by reference: 서로 복사하는 변수 두개의 주소값이 같아진다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-69bc5182-2808-4cc3-8015-90672013c64e" style=""><span class="se-fs- se-ff-" id="SE-c3a1acb3-f766-11ec-b092-7fc752bb6c28" style="">함수 선언할 때 int func(int);형태로 선언도 된다. int func(int, int y, int );형태로도 선언이 가능하다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f9734c7a-7e83-4d35-9d55-ec84529a9223" style=""><span class="se-fs- se-ff-" id="SE-1e0093ca-eb0f-42cb-a0f0-c0183c5bdd9a" style="">또한 함수 선언할 때 int func(int, int y, int ); 이렇게 하고, 정의할 때 다시 int func(int a, int b, int c);할 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-06484a8f-3778-48ba-94dd-866053abb3c5" style=""><span class="se-fs- se-ff-" id="SE-7d48860b-6660-4357-be6d-f6e70fd7e32b" style="">이게 무슨 의미를 가지냐면 선언 할 때에는 함수의 signature만 중요하다는 것이다. 또한 함수의 선언에서 formal parameter는 적지 않아도 된다는 뜻이다. 함수의 정의에서만 formal parameter를 반드시 적어줘야 하는 것이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-67426f2a-1b5f-4225-93db-4633f35794ec" style=""><span class="se-fs- se-ff-" id="SE-f57ee7e6-6768-4229-bab2-fbe06a368ee7" style="">따라서 함수의 선언과 정의를 동시에 할 때에는 반드시 formal parameter를 적어줘야 하는 것이다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7e40009c-e234-436b-b096-33eb11a4ebf1" style=""><span class="se-fs- se-ff-" id="SE-c3a1acb4-f766-11ec-b092-679a0f41439c" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-509b287c-28f9-4e3e-a2c8-0338e75596a3" style=""><span class="se-fs- se-ff-" id="SE-c3a1acb5-f766-11ec-b092-bb9c7d96938f" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-6c3ea574-e1d5-4a53-8da2-3592fa6b039a" style=""><span class="se-fs- se-ff-" id="SE-c3a1d3c6-f766-11ec-b092-cfb4a978d8d1" style="">Ch.10. Managing functions and data</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-16920185-a67a-4e28-ab9e-83d57afce4ae" style=""><span class="se-fs- se-ff-" id="SE-c3a1d3c7-f766-11ec-b092-81aab7fe26e1" style="">전역변수 x와 지역변수 x가 같이 있을 때 전역변수 x에 접근하기 위해 ::x-- (::)를 사용하게 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b3aa9de5-6921-4992-b56b-253a8c90f96a" style=""><span class="se-fs- se-ff-" id="SE-c3a1d3c8-f766-11ec-b092-3dabcfa0b062" style="">'내부 링크가 있는 변수를 static 변수라고 한다. static 변수는 변수가 정의된 소스 파일 내에서 어디서나 접근할 수 있지만, 소스 파일 외부에서는 참조할 수 없다. 외부 링크가 있는 변수를 extern 변수라고 한다. extern 변수는 정의된 소스 파일과 다른 소스 파일 모두에서 접근할 수 있다.' extern 키워드는 두 가지 다른 의미가 있다. 어떤 상황에서는 extern 키워드가 '외부 링크가 있는 변수를 의미' 하고 다른 상황에서는 '다른 어딘가에서 정의된 변수에 대한 전방 선언'을 의미한다. 출처: </span><span class="se-fs- se-ff-" id="SE-c3a1fad9-f766-11ec-b092-bd78f3ee3d87" style=""><a class="se-link" href="https://boycoding.tistory.com/167" target="_blank">https://boycoding.tistory.com/167</a></span><span class="se-fs- se-ff-" id="SE-c3a1fada-f766-11ec-b092-9f9b96d2269c" style=""> [소년코딩:티스토리]</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-bf1eb9d2-8a2a-4d26-9a60-cfddb9fe6e11" style=""><span class="se-fs- se-ff-" id="SE-c3a1fadb-f766-11ec-b092-67b615984795" style="">1) extern const int a = 1; in ex.h, extern const int a = 1; in main.cpp, 이때 main.cpp에 있는 extern은 전방선언을 위한 extern이다. 전방선언(forward declaration)이란 맨 처음에 전방선언 하면 그 다음부터는 접근하고 쓸 수 있게 된다는 것이다. 2) ex.h에 있는 extern은 외부 링크가 있는 변수를 의미한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a3f57dc8-1972-4c51-9d63-84b7b5e79db6" style=""><span class="se-fs- se-ff-" id="SE-c3a1fadc-f766-11ec-b092-998f451fe83e" style="">static 변수들은 compile-time에 다 결정 됨. 특히 static 변수들은 global 변수와 마찬가지로 초기화 안해도 0으로 설정됨. 그 이유는 프로그램의 일반적 프로그램 메모리 segment의 구조를 통해 알 수 있다. 프로그램 메모리 segment의 구조는 1. code/text segment(.code) 2. Initialized data segment(.data) 3. uninitialized data segment(.bss) 4. heap, 5. stack 순으로 stack이 큰 주소값을 가지고, code segment가 가장 작은 주소값을 갖는다. 여기서 중요한 것은 2. initialized data segment, 주로 data segment라고 불리는 곳이다. 여기는 프로그램의 가상 주소 공간의 일부분으로 초기화된 전역변수와 초기화된 static 전역변수를 포함한다. 3. uninitialized data segment(.bss)는 0으로 모두 초기화가 된다. 이렇게 구분되는 이유는 code segment는 ROM에 저장하고, data segment는 ROM에 저장하고 변수를 사용하기 위해서 RAM에 변수를 저장을 하고, uninitialized data segment(BSS segment)는 굳이 ROM에 저장할 필요 없이 0으로 초기화되어 RAM에 저앙하여 바로 쓰이게 할 수 있다.(data segment  출처: </span><span class="se-fs- se-ff-" id="SE-c3a1fadd-f766-11ec-b092-3307eb16ef79" style=""><a class="se-link" href="https://blog.naver.com/PostView.nhn?blogId=cjsksk3113&amp;logNo=222270185816" target="_blank">https://blog.naver.com/PostView.nhn?blogId=cjsksk3113&amp;logNo=222270185816</a></span><span class="se-fs- se-ff-" id="SE-c3a1fade-f766-11ec-b092-cf24ecd416ce" style="">)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-fdc4e184-695c-4f88-955f-afc8648078bb" style=""><span class="se-fs- se-ff-" id="SE-c3a1fadf-f766-11ec-b092-392cd2031d1a" style="">전역변수의 경우에만 extern을 안써도 묵시적으로 extern이 사용이 된 것처럼 파일 밖에서도 사용이 가능하다. main 함수 내에서는 전역변수로 쓰려면 static이나 extern을 반드시 써야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e15e523a-a461-4c39-94d8-600c6a41ec6f" style=""><span class="se-fs- se-ff-" id="SE-c3a220f0-f766-11ec-b092-d71d90a1a267" style="">header 파일에 있는 전역변수를 사용하고자 할 때 extern을 사용해야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-069e07de-108c-4283-b465-8895269bcd33" style=""><span class="se-fs- se-ff-" id="SE-c3a220f1-f766-11ec-b092-c1d5d108b3e5" style="">main 함수 내에static int a;를 사용하게 되면 이 파일 내에서만 사용할 수 있는 전역변수가 만들어진다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-224de977-f0b8-4919-a2bb-7df06f1aa5f9" style=""><span class="se-fs- se-ff-" id="SE-c3a220f2-f766-11ec-b092-1534fde1a99f" style="">static int count(int n) {} 도 사용 가능함. 근데 이거에 대한 내용은 책에 별로 없는듯.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b52da0d7-9a2c-4236-b870-ff9d863d617a" style=""><span class="se-fs- se-ff-" id="SE-c3a220f3-f766-11ec-b092-451a6f79cbc7" style="">formal parameter: 함수 정의할 때 들어가는 parameter. actual parameter: 함수 호출할 때 들어가는 parameter (int foo(int x) 에서 x는 formal parameter, foo(x) 호출할 때 x는 actual parameter.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3247bca9-0d64-45a2-87e0-6feff85732d9" style=""><span class="se-fs- se-ff-" id="SE-da81a469-d701-4927-80d3-dac7a052172a" style="">int&amp; r = x;(int x = 5;) 자료형 뒤에 나오는 &amp;기호는 declaration, that r references x.(r aliases(별칭) x)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4830886a-59a4-4615-808c-bff7d5b8736d" style=""><span class="se-fs- se-ff-" id="SE-468f1716-e4c6-456a-aa30-01509b415309" style="">&amp; == address of operator (*p = &amp;x;)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f0bc9fe8-808e-48d8-bbe0-7b4e78f40246" style=""><span class="se-fs- se-ff-" id="SE-4538f4d9-1a90-4e9c-a0e6-4587c1a0249e" style="">reference 는 선언만 할 수 없음. 정의가 같이 되어야 함. 또한 nullptr 대입 불가능.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-013bd7ce-7673-4712-a0c7-b71163c4cabe" style=""><span class="se-fs- se-ff-" id="SE-909465ab-e247-46a9-b6a7-704be8825bc7" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-6974d7f6-937c-4897-9e40-a5e27190cdd6" style=""><span class="se-fs- se-ff-" id="SE-e81ed580-6f46-4a65-a2dd-6df2276ca914" style="">function overloading</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d7d0fa3e-97f5-4954-95bf-d0ff64670f9a" style=""><span class="se-fs- se-ff-" id="SE-c3a220f4-f766-11ec-b092-ad98531f0b51" style="">overloaded function (중복정의된 함수): 하나의 프로그램 안에 2개 이상의 함수가 같은 이름을 가지고 있을 떄, 중복정의된 함수라고 한다. 2개 이상의 함수가 같은 이름을 가지고 있을 때 함수는 signiture에 의해 구별된다. function signiture는 함수 이름과 파라미터 리스트로 구성된다. 파라미터 리스트에는 formal parameter의 종류,숫자,순서만 상관있고, 이름은 상관없다. 만약 함수의 이름이 갖고, formal parameter의 종류, 숫자, 순서가 다르다면 function signature는 다르다고 할 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-94911a6a-d29e-40bc-9a37-abe049282678" style=""><span class="se-fs- se-ff-" id="SE-c3a220f5-f766-11ec-b092-5515b9e72ede" style="">함수를 선언만 할 때에는 함수의 formal parameter의 자료형만 적어주면 된다. 즉 int foo(int,int,double);만 해도 된다. 또한 함수의 선언할 때 썼던 formal parameter 이름과 함수 정의 부분의 formal parameter 이름이 달라도 된다. 아마 함수의 signature가 달라서 그런 것 같다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-67e9e71a-e412-4177-8efc-fb9442fdcc53" style=""><span class="se-fs- se-ff-" id="SE-c3a220f6-f766-11ec-b092-49587bbbea7f" style="">default argument/parameter: default parameter와 non-default parameter들을 섞을 수 있다. 그러나 이 둘을 섞으려면 parameter list에 있는 모든 default parameter들은 non-default parameter 후에 나타나야 한다. 예를 들어 int foo(int n = 10, int m) {} 은 illegal이다. default parameter는 항상 뒤에서부터 시작해야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c73c670f-98a0-45b6-83b6-dbf5e511e14c" style=""><span class="se-fs- se-ff-" id="SE-c3a24807-f766-11ec-b092-4507847d458d" style="">default argument와 function overloading은 같이 쓰지 않는것이 좋다. void f(){}; 와 void f(int n=0){};은 f();를 호출했을 때 에러가 난다. 에러가 나는 이유는 컴파일러가 어떤 함수를 호출할지 모르기 때문이다. void f(int m){}; 와 void f(int n=0){}; 는 function signature가 완벽히 동일하기 때문에 에러가 난다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7e8aaf8a-bd45-4f08-82d8-61912130e359" style=""><span class="se-fs- se-ff-" id="SE-b306a022-449b-41d4-a7c7-a6cfb94142fd" style="">formal parameter로 const keyword를 쓸 수 있을까? pointer나 reference는 가능하다. 즉 pass by pointer 또는 pass by reference는 const keyword를 formal paramter에 쓸 수 있는 반면, pass by value는 const keyword를 formal paramter에 쓸 수 없다. 그 이유는 다음과 같다. 만약 int foo(int i){}와 int foo(const int i){} 가 있다고 하자. 그리고 main 함수에서 foo(k);를 호출했다고 하자. 이때 compile error가 나타나는 이유는 어처피 main 함수의 k를 foo는 수정할 수 없다. 왜냐하면 pass by value이기 때문에 i는 k를 복사한거여서 별개의 변수이기 때문이다. 따라서 formal paramter가 const로 선언되었건 안 선언 되었건 그냥 차이가 없다. 따라서 compiler가 어떤 함수를 실행해야 되는지 모호하기 때문에 compile error가 나타나는 것으로 해석할 수 있다. 반면 reference/pointer의 경우 main 함수에 있는 k를 변경할 수 있다. 따라서 formal paramter에 const를 쓰고 안쓰고에 따라서 다른 version의 function이 만들어질 수 있다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e10dc0f8-dc7e-4ca2-8156-b51def394ec1" style=""><span class="se-fs- se-ff-" id="SE-c3a2480b-f766-11ec-b092-870077c2aa75" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0bb61fd9-6a0b-436e-8180-3b38f037ec88" style=""><span class="se-fs- se-ff-" id="SE-c3a2480c-f766-11ec-b092-8937c57f0107" style="">pointer</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c664f3d7-a9e2-490f-ab10-208078d85097" style=""><span class="se-fs- se-ff-" id="SE-c3a2480d-f766-11ec-b092-6319007788b7" style="">int *; declaration, that p is a pointer to an int.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5d2bccd9-c924-4281-b1e0-b328bbf5d84b" style=""><span class="se-fs- se-ff-" id="SE-c3a26f1e-f766-11ec-b092-ad7aa5009ec3" style="">* == unary * operator == pointer dereferencing operator (*p = 7;)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-524441d8-bc69-4a7e-9928-3b478c1ae550" style=""><span class="se-fs- se-ff-" id="SE-c3a26f1f-f766-11ec-b092-3d2fe836ff7d" style="">int *p = 5; c++에서 direct integer assignment to pointer를 허용 안함. 특별한 type cast를 써야함. p = reinterpret_cast&lt;int *&gt;(5)를 쓰면 주소 5에서 int pointer로 선언됨. p = reinterpret_cast&lt;int *&gt;(&amp;객체) 형식으로 쓰게 되면 member변수 중 하나의 주소가 대입되는 듯. 이거는 추측.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9ab2300f-1053-4111-9fa7-82e8a2427dce" style=""><span class="se-fs- se-ff-" id="SE-c3a26f20-f766-11ec-b092-d37ef19c181e" style="">int *p; 에서 p를 unitnitialized pointer/wild pointer라고 함. 이 wild pointer를 p라고 했을 때 쓰레기 값을 가지고 있는다. 이때 *p = 500을 하게 되면 error가 발생하게 된다. 그 이유는 wild pointer는 쓰레기값을 가지고 있고, 이 wild pointer는 특정 주소를 가지고 있는 변수이므로 나도 모르는 주소값에 500이라는 값을 가지도록 만드는 것이기 때문이다. 만약 실행 프로그램의 영역에 그 포인터 주소값이 있었다면 error가 나지 않고, 잘 동작하긴 하겠지만, compile된 머신 언어 instruction를, 또는 다른 변수를 override할 가능성이 있다. 그러면 프로그램이 그 변수를 접근할 때 까지 error를 발견할 수 없다. 만약 이때 error가 발생하더라도 error가 발생한 부분은 error를 일으킨 부분의 부근(vicinity)에 없어서 고치기가 쉽지 않다. 따라서 p = nullptr를 쓴다. 이거는 address 0를 포인터에 저장한다. 이 주소는 모든 실행되는 프로그램의 범위 밖에 있다. 따라서 nullptr를 배정한 포인터를 dereference 하게 되면 runtime error가 발생한다. C++11 이전에는 nullptr라는 것을 명시하기 위해 p = 0을 썼는데, nullptr과 0의 차이점은 nullptr은 오직 포인터형 변수에만 대입되고, 다른 자료형에 nullptr를 대입하면 compile error가 뜬다. 따라서 nullptr를 쓰는 것이 좋다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e18cc369-a9cc-404d-b445-543610081b30" style=""><span class="se-fs- se-ff-" id="SE-c3a26f21-f766-11ec-b092-edc971861332" style="">pass by reference via pointers인데, double pointer로 swap함수를 구현하면 어떻게 될까?</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-db657a09-17d6-4e8a-8540-84ef3d4b9740" style=""><span class="se-fs- se-ff-" id="SE-c3a26f22-f766-11ec-b092-f718a1c34d9f" style="">void swap(int **a, int **b) {</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4b08f3b7-6fd5-4965-99ed-50545e9e20ab" style=""><span class="se-fs- se-ff-" id="SE-c3a26f23-f766-11ec-b092-358acee52c77" style="">    int *temp = *a; </span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5503aac7-6e3d-458a-8d1b-7ad919a61a24" style=""><span class="se-fs- se-ff-" id="SE-c3a26f24-f766-11ec-b092-31241cdd64f4" style="">// 이 코드의 오류: int *temp를 써야 함. int**temp를 하게 되면 wild pointer가 됨. 그래서 오류. int *temp = *a를 써야 함.</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-fa2c8dea-cb5a-44d6-a5db-8c8bcc6cff8f" style=""><span class="se-fs- se-ff-" id="SE-c3a26f25-f766-11ec-b092-99ba139344a0" style="">    *a = *b;</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1d2d614f-a126-419d-9c3b-999c169af178" style=""><span class="se-fs- se-ff-" id="SE-c3a29636-f766-11ec-b092-e9bedb871bf5" style="">    *b = *temp;</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-704e5798-7ceb-45b7-be7b-21c97b6a9c12" style=""><span class="se-fs- se-ff-" id="SE-c3a29637-f766-11ec-b092-e9d1f1f0e459" style="">} </span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-8218186e-2e2e-4f92-b53a-bb106821ba19" style=""><span class="se-fs- se-ff-" id="SE-c3a29638-f766-11ec-b092-016ed39a065e" style="">int main() {</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b162895f-d953-43a2-9b64-c5ea6b284376" style=""><span class="se-fs- se-ff-" id="SE-c3a29639-f766-11ec-b092-5776455c55e5" style="">    int A=5,B=6;</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4f9a0821-eeb8-4bc9-b954-47684f8ceffa" style=""><span class="se-fs- se-ff-" id="SE-c3a2963a-f766-11ec-b092-57c4b0ec829a" style="">    int *pA = &amp;A, *pB = &amp;B; </span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-caeacb7c-eaba-4377-a309-3a770f5e4edf" style=""><span class="se-fs- se-ff-" id="SE-c3a2963b-f766-11ec-b092-27d2b83b8942" style="">    swap(&amp;pA, &amp;pB);</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4c1b04c9-4c9f-4a57-a366-b5d71a7e515e" style=""><span class="se-fs- se-ff-" id="SE-c3a2963c-f766-11ec-b092-43f5a8d96f6b" style="">}</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d223ceb6-0529-4afd-b4dd-79f9e99434cf" style=""><span class="se-fs- se-ff-" id="SE-c3a2963d-f766-11ec-b092-6514f2b93e39" style="">하면 원래 pA -&gt; 5, pB -&gt; 6 되고,</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7b8fd150-d295-420a-b86f-43b8736bc144" style=""><span class="se-fs- se-ff-" id="SE-c3a2963e-f766-11ec-b092-213e7d07b1a7" style="">a -&gt; pA -&gt; 5, b -&gt; pB -&gt; 6 되고,</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5f9f964e-aaa3-4688-8b2d-307e5ed9ae97" style=""><span class="se-fs- se-ff-" id="SE-c3a2bd4f-f766-11ec-b092-4dc3038505c5" style="">a -&gt; pB -&gt; 6, b -&gt; pA -&gt; 5가 된다. </span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-45196f4c-f5ff-497d-96c9-8d2ae788c20c" style=""><span class="se-fs- se-ff-" id="SE-c3a2bd50-f766-11ec-b092-0565220776a1" style="">따라서 A,B값은 바뀌지 않는다. 단 pA, pB값만 바뀐다. 왜 A,B 값은 바뀌지 않냐면 변수의 메모리 주소는 절대 변하지 않기 때문이다.</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-546158ba-52c9-45f9-9cc7-130e6d653a5c" style=""><span class="se-fs- se-ff-" id="SE-c3a2bd51-f766-11ec-b092-1bd55029babd" style="">모든 변수의 메모리 주소는 절대 변하지 않는다. 예를 들어 int a = 0;이라고 하면 a의 &amp;a(주소)는 항상 a를 의미한다. 즉 변수란 특정 메모리주소를 의미한다고 할 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-abd52cca-5fdf-4c48-b361-23c8ea8c0235" style=""><span class="se-fs- se-ff-" id="SE-c3a2bd52-f766-11ec-b092-e926505acd5d" style="">즉 변수의 본질은 메모리 주소에 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-6f38fe9b-aed5-4c1a-876d-3014b6205518" style=""><span class="se-fs- se-ff-" id="SE-c3a2bd53-f766-11ec-b092-2506fabb56ba" style="">그러나 우리가 사용하는 변수들은 메모리 주소를 사용하는 것이 아니라 그 메모리 주소가 가지는 값을 접근한다. 포인터 변수도 마찬가지다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e69ed688-c3e0-4475-8fcf-422408ee3384" style=""><span class="se-fs- se-ff-" id="SE-c3a2bd54-f766-11ec-b092-371ec2a17822" style="">따라서 포인터도 변수고, 이 변수는 어떤 메모리 주소를 갖는 특별한 변수다. 따라서 이 변수도 본질은 이 변수값의 메모리 주소에 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-373a7da0-3d12-4007-9134-a31b440418d3" style=""><span class="se-fs- se-ff-" id="SE-c3a2bd55-f766-11ec-b092-e78367d01220" style="">따라서 어떤 변수의 값을 swap 하고자 할 때 그 변수의 메모리주소를 dereference 시키고 그 값을 바꾸면 특정 변수가 바뀌게 되는 것이다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3f3b26ea-d36c-4089-870b-f754a3f5553d" style=""><span class="se-fs- se-ff-" id="SE-c3a2bd56-f766-11ec-b092-87df2e20a78d" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f683de85-ca42-4188-ab67-437385601c19" style=""><span class="se-fs- se-ff-" id="SE-c3a2e467-f766-11ec-b092-3577a3270814" style="">higher-order function: 1)parameter로 함수를 갖는 함수 또는 2)함수를 return하는 함수.</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-cb4623f5-fc69-4328-82ed-37cdb0e46fc9" style=""><span class="se-fs- se-ff-" id="SE-c3a2e468-f766-11ec-b092-f3c47aa0aba1" style="">하나의 함수는 하나의 동작밖에 못한다. 그러나 어떤 함수가 상황에 따라 다른 동작을 할 수 있도록 하면 되지 않을까?</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-83907b05-87a5-445c-80b3-51655eaaf9b1" style=""><span class="se-fs- se-ff-" id="SE-c3a2e469-f766-11ec-b092-67c63594f105" style="">c++는 higher-order function을 function pointer로 달성한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-00c4860c-c3c3-4a30-a843-15deac0e1d0b" style=""><span class="se-fs- se-ff-" id="SE-c3a2e46a-f766-11ec-b092-2503e07221cf" style="">모든 함수는 각각의 메모리 주소가 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-41cace39-6846-4fb3-84b2-97bffe228725" style=""><span class="se-fs- se-ff-" id="SE-c3a2e46b-f766-11ec-b092-4f6b8b9d3083" style="">pointer to function은 특정 함수의 compile된 machine code의 주소를 가지고 있다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4923826f-06bc-4bc4-877c-f8d58b10063c" style=""><span class="se-fs- se-ff-" id="SE-c3a2e46c-f766-11ec-b092-dd5f5043b3f0" style="">int add(int x, int y)   return x+y;</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d2c2fa6d-7c31-462d-a1f9-2ccb412101c1" style=""><span class="se-fs- se-ff-" id="SE-c3a2e46d-f766-11ec-b092-9bdff2469c8c" style="">int evaluate(int (*f)(int, int), int x, int y)   return f(x,y);</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b8041c99-1962-4abe-8040-0b8528ffe2c2" style=""><span class="se-fs- se-ff-" id="SE-c3a2e46e-f766-11ec-b092-1b44cb0089a2" style="">일때 함수 호출은 evaluate(&amp;add, 2,3);형식으로 해야 한다. 즉 higher order function에서 인수가 함수인 부분의 actual parameter는 higher order function의 정의에 적혀진것과 같은 함수의 원형(prototype/signature)과 동일한 함수(callback function)의 주소를 적는다.</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c3a30b82-f766-11ec-b092-136ecd5c0c33" style=""><span class="se-fs- se-ff-" id="SE-c3a30b7f-f766-11ec-b092-0f95b19bff07" style="">주의할 점은 int evaluate(int *f(int,int)) {...} 이렇게 쓰면 안된다는 것. 이것은 evaluate((int *) f(int,int))가 될 수 있음. (참고: </span><span class="se-fs- se-ff-" id="SE-c3a30b80-f766-11ec-b092-e9a78182ec08" style=""><a class="se-link" href="https://stackoverflow.com/a/34474431/19436796" target="_blank">https://stackoverflow.com/a/34474431/1943679</a></span><span class="se-fs- se-ff-" id="SE-c3a30b81-f766-11ec-b092-e91ee075d885" style="">, 폰 노이만 기계는 자료형을 구분하지 못한다. assembly어로 구분해야 함. PC counter로 assembly어 명령어로 구분됨.)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c3a30b84-f766-11ec-b092-ed5302da9850" style=""><span class="se-fs- se-ff-" id="SE-c3a30b83-f766-11ec-b092-5be1cbf152e2" style="">int (*func)(int,int); func = add; func(2,7); 이렇게도 사용 가능.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c0da3f67-ed7d-4e70-9663-176573ccda78" style=""><span class="se-fs- se-ff-" id="SE-c3a30b85-f766-11ec-b092-47d44f3504a7" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b99c7528-09b3-458b-ba8e-85a2228f78f7" style=""><span class="se-fs- se-ff-" id="SE-c3a30b86-f766-11ec-b092-59a3af6fec5e" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-12c06b97-c5f9-4e59-be55-674932a55601" style=""><span class="se-fs- se-ff-" id="SE-c3a33297-f766-11ec-b092-9989478be37a" style="">Ch.11. Sequences</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d9c43def-12de-4cde-a15e-7ca6e1417fd5" style=""><span class="se-fs- se-ff-" id="SE-c3a33298-f766-11ec-b092-5fabc8128c6c" style="">Nonempty sequence == linear ordering이다. linear ordering에서는 첫번째 element에서 마지막 element까지 successor element를 방문할 수 있다.</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b7b761c4-1737-4831-ae0e-ffd2cffb829a" style=""><span class="se-fs- se-ff-" id="SE-c3a33299-f766-11ec-b092-35614ecd2b0f" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-de4ad3ca-f5b4-4277-8770-ab87b17d9413" style=""><span class="se-fs- se-ff-" id="SE-c3a3329a-f766-11ec-b092-63b699a77214" style="">Vector</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4f241798-6c5b-4e17-9b13-3f5184760e32" style=""><span class="se-fs- se-ff-" id="SE-c3a3329b-f766-11ec-b092-c38084541bfc" style="">vector is an object that manages a block of memory, whichis a collection of homogenous values. we can access the values it contains by their position within the block of memeory managed by the vector.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-84e4a2a4-61e1-4011-b4fe-acf5fba913a4" style=""><span class="se-fs- se-ff-" id="SE-c3a3329c-f766-11ec-b092-a3bc2261402d" style=""><span class="__se-hash-tag">#include</span> &lt;vector&gt; 반드시 추가 </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-bb564bf7-c6cc-4bb2-bd1b-cf2d5a6a2737" style=""><span class="se-fs- se-ff-" id="SE-c3a3329d-f766-11ec-b092-517b13dbf667" style="">using std::vector; 하면 vector&lt;int&gt;만 사용 가능</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-cd56fed0-4810-479b-b14a-3c466884bc00" style=""><span class="se-fs- se-ff-" id="SE-31a544a4-6e75-4464-94f0-72f273af3be6" style="">using</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7c00ea63-11dd-45ae-9eaf-dda84c84e5d1" style=""><span class="se-fs- se-ff-" id="SE-c3a3329e-f766-11ec-b092-25a9df334874" style="">std::vector&lt;int&gt; vec; 으로 선언 가능. //template이기 때문에 type 지정해 주어야 함.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7c89a3ac-08eb-4492-8d57-01b4d74db55d" style=""><span class="se-fs- se-ff-" id="SE-c3a3329f-f766-11ec-b092-ff453f0f4754" style="">std::vector&lt;int&gt; vec(10); 으로 size가 10개인 vector 선언 가능</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0f8927a4-dacd-41a3-9e1f-c1c0ccb10c55" style=""><span class="se-fs- se-ff-" id="SE-c3a359b0-f766-11ec-b092-db79e5e8012a" style="">std::vector&lt;int&gt; vec(10,8); 으로 8을 10개 가진 vector 선언 가능</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f8a9e3ef-7c7c-4216-90f7-bdc2a483520f" style=""><span class="se-fs- se-ff-" id="SE-c3a359b1-f766-11ec-b092-4f037b67c33c" style="">std::vector&lt;int&gt; vec{10, 20, 30, 40, 50}; 으로 각각의 element를 개별로 정의할 수 있다. (C++11 이상)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-86d4d1b0-fba2-459f-a9c4-ee06b7afa0b7" style=""><span class="se-fs- se-ff-" id="SE-c3a359b2-f766-11ec-b092-2153d29016e1" style="">// (parenthesis), {curly braces}, [brackets], curly braces안에 있는 element들은 vector initializer list 안에 구성됨.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-85745e29-3765-4fee-a1cb-160ff38efaec" style=""><span class="se-fs- se-ff-" id="SE-c3a359b3-f766-11ec-b092-5fa45e74c5fd" style="">vec[2] 수정, 접근 가능.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d8493f29-ea73-4dab-afb3-88860b6c020a" style=""><span class="se-fs- se-ff-" id="SE-c3a359b4-f766-11ec-b092-675bc1e2e30a" style="">vector의 허용된 index 이상을 접근하게 되면 undefined behavior가 된다. C++ language standard는 undefined behavior를 프로그램 행동이 명시되어있지 않을때 사용한다. 즉 compiler writer들이 맘대로 작성해도 되는 부분이다. 종종 running program은 undefined behavior를 겪게 되는데 이때 crash되거나 가끔씩은 문제가 나타나지 않고 정확하게 행동될 것이다. 따라서 undefined behavior는 system dependent하고 compiler dependent하다. 어떤 프로그램에서는 out-of-bounds access가 logic error로 본다면, 이것은 unpredictable behavior이고, 이 unpredictable behavior는 incorrect behavior다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d3d5f946-e675-4202-9eab-47fddc72c745" style=""><span class="se-fs- se-ff-" id="SE-c3a359b5-f766-11ec-b092-2bdc48965761" style="">그렇지만 out-of-bounds access는 vector 밖의 메모리에 접근하니깐 대부분의 OS에서는 프로그램을 멈추고 error 메세지를 비춘다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d695a287-2ff3-4568-b6c3-23007f2b40ef" style=""><span class="se-fs- se-ff-" id="SE-c3a359b6-f766-11ec-b092-1930f25e587d" style="">vec[x]에 int만 가능.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-73799824-4989-4f04-a4c9-440860e9f3e7" style=""><span class="se-fs- se-ff-" id="SE-c3a380c7-f766-11ec-b092-2b15d018a16e" style="">for(int n : vec) {...} 도 가능. // 범위 기반 for loop이라고 함. range-based loop statement</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e4b9b638-5277-4845-adda-721886591e88" style=""><span class="se-fs- se-ff-" id="SE-c3a380c8-f766-11ec-b092-b5ffb9393dbb" style="">for (double &amp;n : vec) {...} 형태로 vector값 변경도 가능.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9342394c-05f8-417c-9c20-075ab04dc5a0" style=""><span class="se-fs- se-ff-" id="SE-c3a380c9-f766-11ec-b092-4d9c7a26c375" style="">vector의 여러 method들.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-33445404-8dc1-4915-a4cd-717461c8a5b4" style=""><span class="se-fs- se-ff-" id="SE-c3a380ca-f766-11ec-b092-f544eb8dca0f" style="">vec.push_back(10),pop_back(), size(), empty(), clear();</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-57ff00c3-e689-4197-8738-b7e42adfe9e8" style=""><span class="se-fs- se-ff-" id="SE-c3a380cc-f766-11ec-b092-0709ae254470" style="">vec.operator[](2) == vec[2] == vec.at(2) (vector의 out-of-bound access를 방지하기 위한 추가 method, 따라서 index bounds checking을 지원한다. -&gt; out-of-bound access 하면 run-time error 발생)</span><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3a7e0-f766-11ec-b092-430b0ad5a533" style=""> </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e3729aa6-78ac-4026-9691-ddad0fb1ec3c" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-35316f25-7a3d-4710-8120-ceafd1dbbe3f" style="">void F(const std::vector&lt;int&gt;&amp; vec) {for (auto &amp;elem : vec) {...}} 에서 formal parameter에 copy by pass-by-reference로 할 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0013ec45-fb2f-409f-a712-601ba01d884c" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3a7e3-f766-11ec-b092-858b74992669" style="">multidimensional vector: std::vector&lt;std::vector&lt;int&gt;&gt; vec(2, std::vector&lt;int&gt;(3));</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-430cd872-5a23-46eb-8d10-6cf363f21748" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3a7e4-f766-11ec-b092-87f5f769042b" style="">vec[0][0] = i; vec[0][1] = i; vec[0][2] = i; </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2453fcbe-236b-41ca-9069-79e68ab70bb5" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3cef5-f766-11ec-b092-57a74b562380" style="">vec[1][0] = i; vec[1][1] = i; vec[1][2] = i;</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-77161715-1d7f-4837-9ab8-4600febb0064" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3cef6-f766-11ec-b092-23f5b4dd3de6" style="">std::vector&lt;std::vector&lt;int&gt;&gt; vec{ {i, i, i} , {i, i, i} };</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ae5af4fc-9d3a-49ce-81c6-06dc08b85e19" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-f82d54f2-bdfc-4174-a356-0d748e8c751d" style="">multidimentsional vector manipulation: std::vector&lt;std::vector&lt;int&gt;&gt; vec(2, std::vector&lt;int&gt;(3));</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-314778e2-0a6c-41f4-b3b4-0f83789f3e44" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-bde94035-c75c-498b-aaa3-96fffb9f39f6" style="">using Matrix = std::vector&lt;std::vector&lt;double&gt;&gt;하면 void print(Matrix m){} ==  void print(std::vector&lt;std::vector&lt;double&gt;&gt; m){} 과 같은 의미가 된다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-216437a0-3ca1-45d9-9c88-91df85727005" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3cef7-f766-11ec-b092-b195253b5b40" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c6efb755-01cd-4028-9524-4d887c0d0710" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3cef8-f766-11ec-b092-01ea48c6e1a7" style="">Arrays</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a79d6ea1-f9ad-4e15-8380-6ce77b6edfce" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3cef9-f766-11ec-b092-adc81b531523" style="">array도 name과 homogenous value가 있고 value는 block of memory로 위치 접근 가능. global 또는 local variable임. 그러나 객체는 아님. 또한 vector와 달리 C/C++의 core에서 만들어져서(?) <span class="__se-hash-tag">#include</span> 전처리기 사용 안해도 됨.</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c438115a-3f8b-41f1-bbf4-caa37d22c486" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3cefa-f766-11ec-b092-dd6f31f77a4a" style="">static array</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9a0d8580-821c-493b-942c-2664c9fde892" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3cefb-f766-11ec-b092-f1c98b98542a" style="">int arr[10]; 으로 선언 가능. 10 개의 정수로 이루어진 배열.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-07514d00-5b91-4a34-8be7-54a94a1a9bda" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3f60c-f766-11ec-b092-f11178688123" style="">int arr[x];에서 x는 실행시간에 정의될 수 없다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-95ddc983-7900-43cc-8f5a-32276728b598" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3f60d-f766-11ec-b092-fbcbcf8a0533" style="">int arr[] = { 0, 1, 2, 3}; {}-initializer list로 compiler가 element의 개수를 셀 수 있어서 bracket에 숫자를 쓰지 않아도 됨.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-806d404a-d695-45f6-b51f-38a2b4d76c63" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3f60e-f766-11ec-b092-a5c4f058aaea" style="">array를 initializer list{...}로 초기화하면 default value로 0 이 들어감. 예를 들어 int arr[10] = { 0, 1, 2, 3}; 또는 int arr[10] = {};을 하게 되면 default value가 0이 됨. (char형 array도 '\0' == 0이 들어감)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f5ede580-ea8b-4858-9c62-31b71f62483c" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3f60f-f766-11ec-b092-adf37c5b69bf" style="">단 int arr[10];을 하게 되면 배열에는 쓰레기 값이 들어가게 됨. 그 이유는 어떤 모든 함수의 지역변수로 선언되고 초기화를 안하면 쓰레기 값이 들어감. 그러나 전역변수(static/global) 또는 일부만 초기화한 배열을 선언했을 경우(위의 예-  int arr[10] = { 0, 1, 2, 3}) 초기화되지 않은 배열의 index에는 0값이 들어감.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-fba72d37-ec64-47fc-88ac-89e6ae1dabe6" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3f610-f766-11ec-b092-4b613d4c5eb0" style="">배열의 size 알아내는 방법: sizeof(arr)/sizeof(int)하면 됨. 사실은 없음.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-6f54b798-fdb4-4665-ba04-4a3609d4dc2d" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3f611-f766-11ec-b092-6f7ce87f9154" style="">따라서 배열을 formal parameter로 가지는 함수는 배열의 size도 formal parameter로 받아야 함.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-60ebff67-340b-45ba-988d-45168696530d" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a3f612-f766-11ec-b092-a1a46f79865e" style="">arr+i+1 == arr[i+1]</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-96cbf8ff-a7c3-4ed0-84f4-541d430628c1" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a41d23-f766-11ec-b092-9fe6bf19449c" style="">int* p = &amp;a[0];</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a6ea15cf-29ac-42cc-8268-3ba1eaa8ad42" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a41d24-f766-11ec-b092-17bf2a25833d" style="">int* p = a;</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b558cb15-eb03-4632-b938-08e58d4db71e" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a41d25-f766-11ec-b092-c5d9f18d7775" style="">*p++와 (*p)++는 다르다. ++가 *보다 우선순위가 높음.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-188ad4d0-eb88-43f2-9263-4377ea737296" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a41d26-f766-11ec-b092-9f4790a03e96" style="">void print(int a[], int n) == void print(int *a, int n)</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c7c6016a-abf6-4f82-a8e0-b86eeafc767a" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a41d27-f766-11ec-b092-cfa67ffc1c9d" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d4a40ad0-e49b-44f0-a177-f83d511b77ea" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a41d28-f766-11ec-b092-95fe57bc8d8d" style="">Dynamic arrays</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1b521e94-4e84-4c87-9e9b-bfb014c73759" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a41d29-f766-11ec-b092-13b069aac56c" style="">static array의 size는 compile time에 결정됨. 따라서 flexibly-sized array인 동적 배열은 run-time에 결정됨.</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-251735ab-5df7-4da2-96ee-4ff28cccf94a" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a41d2a-f766-11ec-b092-79969647168b" style="">만약 쓸 수 있는 가장 최대의 메모리를 사용하고자 한다면, 충분한 RAM이 없을 것이고, OS가 virtual memory를 만들게 된다. virtual memory는 그러나 프로그램의 속도를 굉장히 줄인다. 왜냐하면 running program의 memory 일정 부분을  disk drive로 부터 실어 나르기 때문이다. 따라서 자원을 현명하게 쓰는것이 좋다. (heap이 stack보다 큼)</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-93380474-4bfb-4c02-a9ac-7b7257dc856d" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a4443b-f766-11ec-b092-458628012198" style="">double *ptr = new double[size];</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3c2a0d7a-f31e-4e82-a5f3-0f64bd27fc37" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a4443c-f766-11ec-b092-65be2a048ce1" style="">delete [] ptr;</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3146fab2-cc8b-473a-9be6-2986c85d34c7" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a4443d-f766-11ec-b092-ff65fec78213" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1e1a6325-74f6-4c88-b77f-c26a6ddc367e" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a4443e-f766-11ec-b092-1315a910a8e2" style="">array를 복사하는 방법</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d85b0b76-d714-435d-bf95-7a0d39d2383f" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a4443f-f766-11ec-b092-55b2423bd7e2" style="">int a[10], b[10]; ...; b = a;  는 compile error가 남. static array는 const pointer처럼 작동하기 때문에, 재배정할 수 없음. 따라서 constant pointer인 b는 assignment operator인 = 왼쪽에 올 수 없다. b가 가르키는 곳은 lifetime동안 평생 그것을 가르켜야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7f3608af-794c-4bdd-9e26-ef982f103891" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a44440-f766-11ec-b092-89936cd32d98" style="">int a[10], *b; ...; b = a; 는 b가 const가 아닌 경우다. 이 경우는 합법인가? 합법이다. 그러나 이 코드에는 어떤 문제가 있을까? 이 코드는 b는 a의 copy가 아니다. b aliases a이다. 따라서 a를 변경하면 b의 content가 바뀐다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b0d6e8f7-1dcd-4c6f-ad4c-a2d91a57d466" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a46b51-f766-11ec-b092-af74dd8ae44f" style="">int a[10], *b; ...; b = new int[10]; for(;;){ b[i] = a[i] }; 이 경우 declare, allocate space for copy, copy the elements 형태로 진행되어 잘 copy가 된다. 나중에 delete [] b;를 해주면 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-86793566-4831-46af-a970-6c61a8fce5c7" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a46b52-f766-11ec-b092-93e4be3c1063" style="">따라서 array copy는 for(;;){ b[i] = a[i] }; 이게 중요하다고 할 수 있다. int *a = new int[10]; int *a = new int[10]; b = a;를 해버리게 되면 delete [] b;를 하게 되면 memory leak이 발생하게 된다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f99e6642-d209-4cb8-9c9a-c7793e2e781b" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a46b53-f766-11ec-b092-09a2bd508be7" style="">memory leak: 재배정된 array가 원래 가르키고 있던 memory block은 copy를 하게 되면 더이상 실행 프로그램은 접근을 할 수 없다. 따라서 array copy의 경우 직접 배정을 하지 말고 원소들을 복사하는 형태로 구현해야 한다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-34c50a6d-7b3d-48b0-b9a6-d8f75f668293" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a46b54-f766-11ec-b092-9fa6022a7252" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7e7c4b0a-9aeb-4ace-b22f-2cd4829ccf96" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a46b55-f766-11ec-b092-db9ac22d8e29" style="">Multidimensional array</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a4fb87a9-19bb-4dfc-9d45-7dd8d36af225" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a46b56-f766-11ec-b092-a94d402fdf2c" style="">선언: int arr[2][3];</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-02ee724e-5ca9-4f4c-8238-677096b1bf02" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a46b57-f766-11ec-b092-bd60bc9cea46" style="">선언: int arr[][3];</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c4cdf343-500f-4304-b263-e37901303e43" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a49268-f766-11ec-b092-e38a7f588a7b" style="">선언: int arr[][3] ={% raw %} {{0,1,2},{3,4,5}}; {% endraw %} 도 가능. 무조건 첫번째 array의 index만 생략 가능하다. 함수의 formal parameter도 마찬가지. (initializer list로 정의를 할 때 해당되는 얘기) 그 이유는 배열은 원소의 offset을 알기 위해 포인터로 변하는데, 이 offset을 계산하기 위해 arr[i][j][k]에서 nj,nk의 차원만 필요할 뿐 ni는 필요하지 않다. (nj == j의 차원,nk == k의 차원, arr[i][j][k]는 offset은 i*nj*nk + j*nk + k, 여기서 ni는 쓰이지 않음.) 출처: </span><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a49269-f766-11ec-b092-b9a25e7da6dc" style=""><a class="se-link" href="https://stackoverflow.com/a/8205191" target="_blank">https://stackoverflow.com/a/8205191</a></span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-bd458d3f-58ad-43ca-9a6f-96d74bcf8306" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c3a4926a-f766-11ec-b092-0f5654d08778" style="">arr[i] = *(arr + i)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e013c319-c846-40ea-85cb-3edc51f2836b" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-5e0845e2-dbb6-430f-a41e-5cff0c0af9db" style="">arr[i][j] == (arr[i])[j] (left-right associativity) == *(*(arr + i) + j)</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9c02640c-08a0-4ce2-8e73-cb362fae0784" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-6c5524ba-79ca-499b-aec6-4cb54949c619" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-31ef4780-def3-4a4f-abe3-efbf9b6e1113" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-ff54e78f-275e-4e40-8acc-900d86a69d1f" style="">C string</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-44a93522-7db6-411d-a0d5-1d98038e496e" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-7be361e1-c0e2-45ab-9bb0-e9a70c9c2599" style="">C array가 cout 되는 이유는 c string은 끝에 '\0'- null 문자가 들어가있다고 한다. 그래서 이거를 문장의 끝으로 인식해서 처리한다고 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f822272a-d069-4de6-aad5-7699acc8a96a" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-8e202e67-f044-461b-ae3a-ce1307ce2ebf" style="">char *word1 = "Howdy"; std::cout &lt;&lt; word &lt;&lt; '\n'; // 안전하다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-fb59ad7a-6b3c-4584-b547-aa06fdb81b4c" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-48000a33-01f8-43de-bb37-13a10eb6f1bc" style="">char word2[256] = "Howdy"; std::cout &lt;&lt; word &lt;&lt; '\n'; // 위에꺼보자 안전하지 않다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-76798d88-1d6a-4dbc-8860-b19a06c76e48" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-0bf9cb24-bb1b-4e41-8d9a-49bd282a716d" style="">왜냐하면 256자 이상의 char를 입력하면 buffer overflow가 일어난다. 이거는 심각한 logic error를 일으킬 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-141eeecf-16bb-4032-b70e-2ebab3296b17" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-2bacb002-419e-407c-973b-2bcbfe5c1ff7" style="">std::cin에서 공백도 포함하는 방법:#include &lt;cstudio&gt; char word[10]; fgets(word, 10, stdin); std::cout &lt;&lt; word; fgets는 standard C 함수. stdin은 C의 구조체, std::cin과 비슷한 구조체.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-99d60f50-2ccc-474b-a98f-8a039e7fc7c1" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-49b418b4-36a7-4121-8ff6-4cf74fbaa75e" style="">그러나 char *word; std::cin &gt;&gt; word; 하면 심각한 오류가 남(undefined behavior). std::cin에서 가져온 문자들을 저장할 buffer를 할당하지 않기 때문이라고 하는데, C를 공부해야 이해할 수 있을 것 같다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a8c658ea-0d38-4dae-810e-1361bf49ddb4" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-89bbe98f-2fea-43c8-bd0d-c1f6b5a8879b" style="">C string method</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4eac11d7-7e5a-4aba-bfea-a36bf0d2a024" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-80bc7e0e-ed35-4fc2-93d3-7c151210025a" style="">int strlen(const char *s): '\0' 미포함 s 문자 길이 </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f346737b-cea5-407c-b661-ea2821a617b6" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-b1fd5d4f-44f7-4915-91f0-bfe19b7bee9d" style="">char* strcpy(char*s, const char *t): '\0' 포함 t를 s로 복사, 이때 s가 t를 다 가지고 있을 수 있도록 큰 buffer여야 함. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4de76262-684d-4cb6-aac8-878750f5688c" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-a13250c0-d86c-46ad-bc63-8c098a6e9bbf" style="">char* strncpy(char *s, const char *t, unsigned n): '\0' 포함 최대 n만큼 t를 s로 복사, 이때 s가 적어도 n이상의 buffer여야 함.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-711b8e11-10b7-4e14-a4d7-881d3a2522a6" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-6608d36d-23de-4515-9bf5-049033c7e84b" style="">int strcmp(const char *s, const char *t): 사전 순으로 s가 t보다 먼저 있으면 -1, s가 t가 같으면 0, s가 t보다 뒤에 있으면 1.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-25468c7d-dab7-4dca-8990-6a7b28f414ed" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-8a21a9dc-3abd-45d5-971d-16eddf816a57" style="">int strncmp(const char*s, const char*t, int n): 맨 처음 n개 문자만 사전 순으로 s가 t보다 먼저 있으면 -1, s가 t가 같으면 0, s가 t보다 뒤에 있으면 1.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-27eb8153-7c28-4578-aa3f-abb2fe123d05" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-d3268e69-0b6d-4748-9c88-a6addc7607fd" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9d83b063-8283-43c9-b327-866fd4c90045" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-624841ea-d593-4da1-9179-0df5f6049258" style="">Command-line arguments</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-6adbb1dd-1ffb-4a2e-ad1d-5461fc0b17de" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-0555fdb9-43a2-4d45-a7d5-bf1009cb8c73" style="">int main(int argc, char *argc[]) { for (int i = 0 ; i&lt;argc;i++) std::cout &lt;&lt; argv[i] &lt;&lt; '\n';}</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-8e35e6d6-9225-4e17-912a-98ddb5d0297a" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-869cbebe-2232-4ea5-9844-db815b0070dc" style="">한 다음 command line에서 파일 이름이 example.cpp였다면 example qwer asdf zxcv라고 치면 </span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3aaef79f-a120-4511-ad61-749e8638dd8b" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-f26e7764-9c53-42f6-981c-d31a3c5b5e3f" style="">example</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3743cda0-72c5-49d8-a559-f84ec3697e9d" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-44c960f7-7a40-4164-af00-a9cf15d5f58f" style="">qwer</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f94305c1-d32a-496c-bc8b-5e7583cb5441" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-a58c67ae-c3ce-43b8-a2fe-35d930cc9f00" style="">asdf</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2b704d79-63bc-4cd6-a1b3-67813f60d385" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-364a5fab-fe03-4b01-b830-5ab363713858" style="">zxcv</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-00522527-44c7-464f-a77e-0b16eefcda98" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-4d2b1ef5-1d03-4bad-9e4a-a03f87a25443" style="">가 나온다. 즉 char *argc[]는 argc가 array of C string이라는 것을 의미한다. 따라서 argc[0]는 파일명 그 자체고 argc[1]은 qwer, argc[2]은 asdf, argc[3]은 zxcv임을 알 수 있다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d833bcce-de26-4202-98cb-88f84f211629" style=""><span class="se-fs- se-ff-" id="SE-c3a4926b-f766-11ec-b092-eb0c014e7e92" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d4957045-80b9-4a99-8137-872feb19dfb5" style=""><span class="se-fs- se-ff-" id="SE-c3a4926c-f766-11ec-b092-95a7848b6077" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-672aa221-64b3-46dc-b713-d6d7038ad924" style=""><span class="se-fs- se-ff-" id="SE-c3a4e08e-f766-11ec-b092-81314fccbe62" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7842d0ca-b7f6-4e20-ad7c-175d86de854e" style=""><span class="se-fs- se-ff-" id="SE-c3a4e08f-f766-11ec-b092-21782959159a" style="">Ch.12. Sorting and searching - 생략.</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2fde1de7-a0af-4782-bf9b-6a03b1c459d2" style=""><span class="se-fs- se-ff-" id="SE-c3a507a0-f766-11ec-b092-fb1f45ec117d" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-141ac0d9-d329-4b8d-98e3-927e9b03b396" style=""><span class="se-fs- se-ff-" id="SE-c3a507a1-f766-11ec-b092-ad39e196e072" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-89e29fc8-4769-409c-b828-98e26d67898e" style=""><span class="se-fs- se-ff-" id="SE-c3a507a2-f766-11ec-b092-c9aa2619bc56" style="">Ch.13. Standard c++ classes</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2e8a9017-2dff-4d06-8562-273ea22100a0" style=""><span class="se-fs- se-ff-" id="SE-c3a507a3-f766-11ec-b092-fdfe6c7cd607" style=""><span class="__se-hash-tag">#include</span> &lt;string&gt;: operator[] operator= operator+= at length size find substr empty clear append 등등(cplusplus 웹사이트 활용, 또한 visual studio . 찍어서 method 활용)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-8134b5e1-0db8-4293-ab60-fe1999f60898" style=""><span class="se-fs- se-ff-" id="SE-6d296a26-b97f-40c0-972c-28c64bab4f18" style="">공백도 포함해서 cin하는 방법: std::getline(std::cin, str); (str type: std::string)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c583e506-339b-4346-a0fa-2f3e7af14a63" style=""><span class="se-fs- se-ff-" id="SE-f14e3a15-8664-4aff-9b31-af6ce70527f1" style="">std::cout &lt;&lt; x &lt;&lt; y; 의 의미는 std::cout.operator&lt;&lt;(x).operator&lt;&lt;(y);이다. std::cin 도 마찬가지. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-18d1c521-c9cb-42c2-9450-891617e9c07b" style=""><span class="se-fs- se-ff-" id="SE-c3a57ced-f766-11ec-b092-bd4b8b1f6b00" style=""><span class="__se-hash-tag">#include</span> &lt;fstream&gt;</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5af252e3-d216-4718-8f8a-7416367b0ac2" style=""><span class="se-fs- se-ff-" id="SE-c3a57cee-f766-11ec-b092-a97cc77c3e8c" style="">std::ifstream fsTemp;</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f177c9bd-b0c3-4306-902c-afdda506cadd" style=""><span class="se-fs- se-ff-" id="SE-c3a57cef-f766-11ec-b092-7fdf0f0332b8" style="">std::string str;</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b54acc2a-9b0b-487a-8e84-8628cb13e654" style=""><span class="se-fs- se-ff-" id="SE-c3a57cf0-f766-11ec-b092-6b75c6d59373" style="">fsTemp.open("practiceFile.txt")</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a752e895-01af-4215-ab82-e8454b6c97ce" style=""><span class="se-fs- se-ff-" id="SE-c3a57cf1-f766-11ec-b092-378b7c2f14ef" style="">if (fsTemp.good()) {</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-30255d84-cece-4f1f-934c-5b0ec96ea613" style=""><span class="se-fs- se-ff-" id="SE-c3a57cf2-f766-11ec-b092-4754eb0ebbbe" style="">    std::getline(fsTemp, str, ',') //&lt;string&gt;의 함수</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4b0464c4-3b4e-4e1f-8d1e-31f2da929a1a" style=""><span class="se-fs- se-ff-" id="SE-c3a57cf3-f766-11ec-b092-cf312012cb37" style="">}</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c3979721-f508-4b9d-9ede-b1645326635b" style=""><span class="se-fs- se-ff-" id="SE-c28a075f-1923-43aa-89cc-b0ae1c7a2ff9" style="">std::cin은 문제가 발생할 수 있다. enter를 치면 LF가 남아있을 수 있기 때문이다. std::cin이 입력 받을 때 LF(enter 키)를 인식하지만 LF키를 사실 없애주지는 않는다. std::cin.unsetf(ios::skipws); 를 하게 되면 skip whitespace를 설정 해제하게 되어 char를 std::cin하는 경우 space(32)와 LF(10)를 모두 인식하고 buffer에 저장하게 된다. 따라서 나머지 std::cin 구문이 buffer 안에 있는 문자가 들어가 생략이 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-158c74ef-986c-4b6a-820a-45c817de4e88" style=""><span class="se-fs- se-ff-" id="SE-b62ef8a7-24e4-4cc1-8028-b2a086e3142e" style="">따라서 std::getline(std::cin, str); 하기 전에 무조건 std::cin을 썼으면 std::cin 후에 std::cin.ignore를 해야 한다. (</span><span class="se-fs- se-ff-" id="SE-ec6c19da-4d38-4b62-95bb-128bf354f8fb" style=""><a class="se-link" href="https://cboard.cprogramming.com/cplusplus-programming/122401-how-do-i-allow-spaces-cin.html" target="_blank">https://cboard.cprogramming.com/cplusplus-programming/122401-how-do-i-allow-spaces-cin.html</a></span><span class="se-fs- se-ff-" id="SE-8dad7cc8-be7e-4ccd-99f5-33192711d4f0" style="">) 그래야 buffer 안에 있는 것들을 제거해줄 수 있기 때문이다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c3f137c1-c4a3-48ab-ae68-8d098d671ada" style=""><span class="se-fs- se-ff-" id="SE-b34bfb00-a47c-4e45-941d-5201588c722b" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0302fdb4-1d60-423f-9aed-eecabb082aa2" style=""><span class="se-fs- se-ff-" id="SE-554ef63a-f75d-467b-8457-1675574219f2" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e01a067e-06d7-4ab7-a7f9-03afa9bf81c2" style=""><span class="se-fs- se-ff-" id="SE-00ffee35-bf3b-4e3a-bdc5-c084e34505a8" style="">Ch.14. Custom objects</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-dbf50cba-aa1d-4251-b982-b77061cb85b2" style=""><span class="se-fs- se-ff-" id="SE-bc34e1d2-9fa9-4fa8-8732-ede33308e1ab" style="">encapsulation: 캡슐화 한다는 뜻. 캡슐화 한다는 것은 무슨 의미인가? 캡슐화란 정보 은닉이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-aad32ed7-07b6-458b-8d2f-21712341dd12" style=""><span class="se-fs- se-ff-" id="SE-e6b2588e-7c6b-4edb-820f-c8af7065003e" style="">encapsulation은 정보 은닉한다는 개념이다. 왜 어떤 정보를 client에게서 숨겨야 하는가? 복잡한 프로그램/시스템 에서는 객체의 내부에 무분별한 접근을 허용하면 재앙적이다. 그 이유는 서투른 프로그래머의 한가지 변경은 전체 시스템을 망가뜨릴 수 있기 때문이다. C++에서는 public과 private으로 field(data member)와 method들을 정의 할 수 있다.(member는 class 내의 변수와 함수를 의미. class 내의 변수를 data member, class 내의 함수를 member function이라고 함.)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-54d4f3b7-5e96-4769-a54c-cb1cd9e140fe" style=""><span class="se-fs- se-ff-" id="SE-c4d57117-84a3-419e-92a4-b0caded9c4f9" style="">public과 private으로 field와 method를 정의하는 순서는 accessibility rule 또는 visibility rules 또는 permission이라고 불리는데, 이거는 class/object의 어떤 부분이 바깥 세상에게서 접근 가능할지를 결정하는 법칙이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b65449e1-3908-41e4-9a40-89ad93b73ab4" style=""><span class="se-fs- se-ff-" id="SE-51b34677-79ac-4ec5-89fa-8c2e32352408" style="">accessibility rule은 다음과 같다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f230cf37-ed6c-4e3c-b170-e8ffd817cb1d" style=""><span class="se-fs- se-ff-" id="SE-1a109eaf-50c1-4501-9d32-060c37282f2f" style="">1) private field rule: 보통 field는 private으로 둔다. 이는 사용자 코드로 하여금 object를 undefined state로 가지 않게 만들 수 있다.(e.g. denominator를 0으로 두는 것.) 그러나 private field rule에는 한가지 예외가 있는데, primitive type와 같이 다루는 간단한 object들은 field를 그냥 public에다가 둔다. 왜냐하면 double 이나 int와 같은 built-in primitive type은 사용자 접근으로부터 보호를 받지 않기 때문이다.(e.g. Point.x, Point.y)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-faaa80a5-5b18-4068-97e5-d389f63960f4" style=""><span class="se-fs- se-ff-" id="SE-a5bb074f-d26e-4a4a-adf0-62cc814ecb55" style="">client code에 어떤 service를 주는 method들은 class의 public으로 설정한다. 이때 object를 illegal state(i.e. undefined behavior)로 만들지 못하도록 method들을 만들어야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0cfd0a5e-9f94-4ba5-964d-712378b6bf92" style=""><span class="se-fs- se-ff-" id="SE-a35ed106-a8a5-485c-8e98-2cedf5b521e6" style="">service method를 도와주지만 바깥 세상에서 쓰의는 것을 의도하지 않은 method들을 helper method 또는 auxiliary(보조) method라고 부른다. helper method는 private에서 정의된다. 이 helper method는 public method를 더욱 간단하고 일관성있게 만든다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-578cd780-a3d6-45a1-b4a9-3d05b46f0500" style=""><span class="se-fs- se-ff-" id="SE-ced93207-e641-4cde-b89d-38b4bd42b8ef" style="">이 encapsulation의 장점에는 여러가지가 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3bed081b-7c91-4f9a-a212-86e2707f9dc9" style=""><span class="se-fs- se-ff-" id="SE-d44e9a72-36aa-4931-953d-8080ecdb4ff5" style="">그 중 하나는 1) flexibility in implementation을 준다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9c412b64-d95d-4503-98db-c3500a00bf73" style=""><span class="se-fs- se-ff-" id="SE-593f82e3-c824-4448-b4fb-c0d0bf59d72e" style="">class interface(visible part)는 바뀌면 안된다. 그 이유는 class interface가 바뀌면 그 class를 사용하는 client code를 break할 수 있기 때문이다. 이때 그 class interface가 client code를 break했다고 표현한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-39d3e500-d2d1-4db1-8e73-aed3c36d291f" style=""><span class="se-fs- se-ff-" id="SE-7a741476-7dd6-453e-a003-b357b437ecee" style="">반면 class implementation(hidden part)은 바뀌어도 된다. client가 볼 이유가 없는 곳이다. 왜냐하면 이 class가 어떻게 돌아가는지는 client의 관심사가 대부분 아니기 때문이다. client의 관심사는 class가 무엇을 하느냐. 즉 class interface이다. 따라서 class implementation 부분을 flexible하게 변경할 수 있다는 장점이 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-810e3581-0ae4-45e9-ba5c-034b42271dd5" style=""><span class="se-fs- se-ff-" id="SE-31e8ec3e-88ac-4ca6-bea5-a71d36bc58e4" style="">또한 2) 복잡성을 숨길 수 있고, 3) client가 ill-defined state로 object를 바꿀 수 없게 해 error를 줄여주며, 4) client는 사용하는 class의 복잡성을 알 필요가 없어 object를 돌아가게 하는 class의 복잡성을 고려하지 않아도 되고, 5) class designer는 private 부분만 수정해서 다시 배포해도 되므로 client code의 복잡성을 고려하지 않아도 된다. 즉 client가 class를 어떤 맥락에서 사용해도 되는지 몰라도 된다는 장점이 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-60d93a4c-8ba7-4d10-9353-2ecf46bc6f2b" style=""><span class="se-fs- se-ff-" id="SE-847726ea-19ce-4a9d-a1c9-286afb6526e2" style="">그러나 c++의 encapsulation에는 단점이 있는데, 객체를 자신의 method으로부터 보호할 수 없다. 이 말은 무슨 말이냐면 method는 정의된 모든 class member에 대해 접근할 수 있다. 따라서 class의 어떤 부분은 몇몇 method로부터 보호받아야 한다고 생각하면 그 class를 몇개의 class로 나누어 구성해야 한다. </span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-949e5ebf-59b1-44c1-8301-0a03c0047eaf" style=""><span class="se-fs- se-ff-" id="SE-d27408a2-ffda-44dd-83e6-6f5edb6508d8" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-01cf8386-493c-481f-ab4b-7f1e788967ab" style=""><span class="se-fs- se-ff-" id="SE-a3c4102e-60bc-4e13-9a93-7c719b1ce159" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5b2a2b3e-4143-42f9-ab4c-55f9e9deafeb" style=""><span class="se-fs- se-ff-" id="SE-67e77de8-2c30-4d8e-8aa1-4f9e01727592" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9c3f484b-61ae-488a-a250-29c81ca49aa4" style=""><span class="se-fs- se-ff-" id="SE-560c8e30-29cd-4f7c-a50b-e68e3fa5a2af" style="">Ch.15. Fine tuning objects</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-738d4ae3-2179-403c-90db-b75094d73c00" style=""><span class="se-fs- se-ff-" id="SE-fe838a7d-158d-4eab-9c37-969b3099e925" style="">this (pointer)는 사실 모든 method에 전달되는 implicit parameter다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-6437de42-4b32-4aa0-bb4f-3ecb7052c6a8" style=""><span class="se-fs- se-ff-" id="SE-c660cf3f-8d3b-48e5-9e5b-51265816aae7" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-97171fd2-0caf-4fe6-a81e-562fa351a4eb" style=""><span class="se-fs- se-ff-" id="SE-b0b4cd4a-67a8-43ad-824f-2cd68b3427f4" style="">const</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c6d1f00b-d086-4a24-9c68-53041c4ca691" style=""><span class="se-fs- se-ff-" id="SE-d15965de-4c75-499a-ae47-9a23cdd39826" style="">우리가 사용자 정의형 data type을 이용해 어떤 객체를 const로 정의했다고 했을 때, 그 const object에 대해 모든 method를 사용을 못할까? 아니면 data member를 수정하는 method만 사용하지 못할까?</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d6e596ec-bb8b-443f-af6e-20acd763f107" style=""><span class="se-fs- se-ff-" id="SE-975ac52b-e804-4668-bb94-aa6e32d20b32" style="">답은 '모든 method를 사용하지 못한다' 이다. 왜 그럴까? 그 이유는 compiler는 특정 method가 어떤 일을 할지 모르기 때문이다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0c66601f-2497-4420-8d50-0dbbdb622bb4" style=""><span class="se-fs- se-ff-" id="SE-48f30e0b-e24e-4778-a803-d19c2c1958cd" style="">따라서 어떤 method가 object의 상태를 변경시키지 않도록(== data member, private 부분을 변경시키지 않는 method) 정의하려면, 그 method는 const로 선언이 되어야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-bf5649b1-e989-402f-a94f-54601e992058" style=""><span class="se-fs- se-ff-" id="SE-41efa651-b85d-4d66-b770-08a23b3532b9" style="">const로 선언하게 되면, method를 object의 상태를 변경시키지 않도록 정의했는데, object를 변경시키는 code가 들어간 경우 심각한 logic error를 갖게 되는데, 이를 방지할 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-6025d6fc-7a90-4072-8b27-4f61ee50e2c9" style=""><span class="se-fs- se-ff-" id="SE-5152d3f0-7e6f-4654-8d1c-2bdefeea0775" style="">method에 const를 선언하는 방법은 int func() const {return ...} 이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f3b3a093-1e1b-4362-bf6b-24939a694b74" style=""><span class="se-fs- se-ff-" id="SE-4e50fd72-379f-41db-bedf-93f891a7e269" style="">non-const/const method과 non-const/const object의 관계를 알아야 한다. const object는 const member를 사용할 수 있지만, non-const member를 사용할 수 없다. 그러나 보통의 object(non-const object)는 const / non-const method를 둘다 사용할 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-85347b99-19e5-45ab-8cdd-4eceb89e8ca1" style=""><span class="se-fs- se-ff-" id="SE-15e8e1fd-eba9-4ef9-9e2a-508d0742c5a0" style="">따라서 정리하자면 const object는 non-const member를 사용할 수 없고,나머지 const object는 나머지 method를 사용할 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1a2f33a2-ccc0-4cf3-8170-818624f1558b" style=""><span class="se-fs- se-ff-" id="SE-1181292e-50ca-4860-a5ff-3c348e5b3d5e" style="">const function(member function) overloading: const method와 non-const method는 overloading 할 수 있다. 그 이유는 그 class의 object가 const object인 경우 const function이 실행되고, class의 object가 non-const object인 경우 non-const function이 호출되기 때문이다. 즉 두개의 함수는 별개의 함수라는 것이다. (function 뒤에 const를 붙이는 것은 method에서만 그렇게 한다. 왜냐하면 function 뒤에 붙는 const keyword는 const object가 유일하게 invoke할 수 있는 method로 만들어주기 때문이다.)</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-bd2a2959-afb8-4cfc-9e5b-a7ed1727beaf" style=""><span class="se-fs- se-ff-" id="SE-6ed75a5c-6a0d-4bcd-92d8-de0d5428cd74" style="">​</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9b48fd41-c4c2-4daa-9ce9-4bf088906a93" style=""><span class="se-fs- se-ff-" id="SE-e20278ac-0251-4623-9042-d8c8a9a6f2bc" style="">ODR은 one definition rule의 약자로, 한번만 정의해야 한다는 뜻이 있다. 한번만 header file을 포함시키는 방법은, <span class="__se-hash-tag">#ifndef</span> COUNT_H_ <span class="__se-hash-tag">#define</span> COUNT_H_ <span class="__se-hash-tag">#endif</span> 이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ef4e6097-f3a0-41bb-a36f-df14a754145d" style=""><span class="se-fs- se-ff-" id="SE-f24ed324-02b0-4ba8-a594-7835573e81db" style="">나중에 debugging할 때 <span class="__se-hash-tag">#define</span> DEBUG <span class="__se-hash-tag">#ifdef</span> DEBUG ..실행코드.. <span class="__se-hash-tag">#endif</span> 하면 전처리기가 debug일 경우 실행코드를 포함시켜준다. 더 구체적인 것은 구글링.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c2760260-a060-4a78-93f0-56a73efd925c" style=""><span class="se-fs- se-ff-" id="SE-7aad55c1-8576-4f19-ba4f-7fe3962b0a34" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-cbf6a2d7-1598-45c7-9f55-1a013b62a03d" style=""><span class="se-fs- se-ff-" id="SE-47e5b3c3-7e0c-49a4-af11-3572eb7c8578" style="">Static member</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e7f70aeb-76a3-499a-8ce5-dca342f4e3d3" style=""><span class="se-fs- se-ff-" id="SE-988854b6-52f3-4a57-9921-c47c127e2afc" style="">한 class에 하나만 생성이 됨.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-dab4757a-0422-432b-ad03-1050804c73b0" style=""><span class="se-fs- se-ff-" id="SE-6cd75e14-5d63-4e11-b429-904cd4079a21" style="">class 내부에서 static 변수를 정의하면, 모든 그 class object에 대해 동일한 static 변수를 공유한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ce5fb60e-cf89-4476-ad73-7bf82c4b01ca" style=""><span class="se-fs- se-ff-" id="SE-f8f3b0ed-dee8-41d5-b205-c9ccd5d4c1a2" style="">static 변수는 특이하게도 class 선언 외부에서 정의되어야 한다. 예를 들어 class 이름이 Widget이고 private에 static int quantity;라고 선언되었으면 항상 class 선언 밖에서 static int Widget::quantity = 1; 라고 정의해주어야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2ca6f912-55df-4faa-8520-4c6976678ce9" style=""><span class="se-fs- se-ff-" id="SE-ffd96217-601d-4ebd-bef8-49723f48e79a" style="">그러나 static const 는 class 선언 외부에서 정의할 필요가 없다. 예를 들어 static const int RED = 1;라고 바로 정의가 가능하다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c4869c6f-f2dd-49af-90da-3c9c18ca2d08" style=""><span class="se-fs- se-ff-" id="SE-836c7a96-07bf-4832-bb1d-08aa48997f8e" style="">static method도 있다. static method들은 non-static members (non-static variable and non-static method)를 접근할 수 없다. 그 이유는 class object 없이 호출할 수 있기 때문이다. 오직 static member들만 접근이 가능하다. 그러나 non-static method는 static/non-static member를 모두 접근 가능하다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-50d933b3-1ec2-4fec-9515-252b041f37f2" style=""><span class="se-fs- se-ff-" id="SE-45fe9843-88e7-45ca-b7ad-6435522e3667" style="">모든 non-static method들은 this라는 implicit parameter를 갖는다. static method는 this parameter를 가지지 않는다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-171c5d12-51cc-4baa-88e3-0664d6784da8" style=""><span class="se-fs- se-ff-" id="SE-cd091dcc-b478-479d-af07-ff0851a42172" style="">static method는 class 선언 내부에서 정의가 가능하다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c5f6d0bc-2b8b-4ae4-a770-c547205afc71" style=""><span class="se-fs- se-ff-" id="SE-ec9a12b1-c5d4-463f-8c69-4fd2a6d375dc" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-263f10e2-4c0b-46b3-855e-63be176c4302" style=""><span class="se-fs- se-ff-" id="SE-0cc528ce-50af-4c1c-b7d3-4acbe3243b40" style="">friend</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-8a07f2b4-7ee4-4120-bb03-99d513067fbc" style=""><span class="se-fs- se-ff-" id="SE-15a55ab0-94ee-4456-bf46-3cb144f75443" style="">friend function은 class 내부 function이 아니다. free function(non-member function)이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-dd5132bc-3ad2-4836-99ad-cd075252cfb9" style=""><span class="se-fs- se-ff-" id="SE-6af92f2e-15eb-4682-a9c1-6fa1d0cbe981" style="">class 선언 밖에서도 private member를 접근하기 위해 friend를 사용한다. class 내부에서 friend int func() {}선언하고 함수 밖에서 friend keyword를 빼고 정의하면 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-70197823-250f-496f-a9fd-05305fc916f0" style=""><span class="se-fs- se-ff-" id="SE-e7e7aa33-fcf6-470e-ac2b-5ac7206c90e3" style="">private 부분에 선언하던지 public에 선언하던지 차이가 없다. 주로 public에 선언하는 것 같다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9de79ae7-08c0-4184-9886-7d332cbde9a5" style=""><span class="se-fs- se-ff-" id="SE-760494cd-feec-49e7-a337-6ff069b0d69b" style="">friend class Gadget라고 class 선언 내부에 선언할 수 있다. 그러면 Gadget이라는 class 정의에서 friend를 선언한 class의 private member에 접근이 가능하다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-221c8c7b-3668-41ac-b027-75ff79ebb04e" style=""><span class="se-fs- se-ff-" id="SE-02a2b586-a59e-4148-951b-d8a140f19b7f" style="">friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const X&amp; x) {os &lt;&lt; ...; return os;}</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0e8bc8f1-ed17-4925-bb5f-3df1623ed6a6" style=""><span class="se-fs- se-ff-" id="SE-6ce5817f-4f74-42f8-98ad-ea73a142d34a" style="">operator&lt;&lt; overloading(중복정의)의 std::ostream formal parameter에 const가 붙으면 안되는 이유는 cout 출력 오류 뜨는 경우 ostream 객체가 수정이 되기 때문이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-af6035df-5137-4115-995b-6abc840f6558" style=""><span class="se-fs- se-ff-" id="SE-b75be2b0-358b-41b6-9099-e9f6c3c85591" style="">friend의 관계는 자동적으로 대칭적(symmetric) 관계가 아니다. class 선언 내부에서 friend class A;를 하게 되면 A만 자기의 private를 접근할 권한을 얻지만, 자기는 A의 private를 접근할 권한을 얻지 않는다. 사실 friend가 아니라 상하관계다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-eca5d3de-4eaa-4d4e-8d50-3dcf27b1094a" style=""><span class="se-fs- se-ff-" id="SE-a02649b2-345a-49ad-9636-92a7e02fe76b" style="">또한 friendship 관계는 전이(transitive) 관계가 아니다. A가 B의 private 접근 권한이 있고 B가 C의 private 접근 권한이 있을 때 A가 C의 private 접근 권한을 가지지 않는다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-72b0a54e-21c1-45da-9422-e0457027e34e" style=""><span class="se-fs- se-ff-" id="SE-690b53d8-24d2-4282-94c8-7c0c472b5df9" style="">좋은 객체지향 디자인은 friend를 잘 사용하지 않는다. 그 이유는 encapsulation을 약화시키기 때문이다. friend는 ill-defined state를 만들 가능성이 더 커지기 때문이다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ee2b7d0a-a7cc-473d-a3e6-b87a82ba0f7a" style=""><span class="se-fs- se-ff-" id="SE-15cae58a-b608-4e0d-8a83-37265b2c9042" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0438f9ea-91d5-4efd-a578-1cbceadb46f9" style=""><span class="se-fs- se-ff-" id="SE-03e84846-d56e-42df-9920-48394fb4c2c0" style="">Operator overloading</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-86d737e3-7f94-41e9-896f-2f1668daadd1" style=""><span class="se-fs- se-ff-" id="SE-3ad8fc22-41ef-4f9b-8cce-d76e5d4536e9" style="">non-member function(전역 scope에서 정의하는 방법)으로 정의하는 방법과 member function으로 정의하는 방법이 있다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1edca132-5735-4094-a04d-d8404aafe7d3" style=""><span class="se-fs- se-ff-" id="SE-1c47ccf9-6271-46b4-805e-916f0da60bdc" style="">non-member function으로 정의하는 방법은 A operator+(A a, A b) {} 이고</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7b701398-9c0c-463b-bc9b-30c364541392" style=""><span class="se-fs- se-ff-" id="SE-8c8b73e8-9851-4d89-b1c5-bbd86e90ff1d" style="">member function으로 정의하는 방법은 A operator+(A b) {}이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2468225e-99f8-47a6-900a-fb02d49c8656" style=""><span class="se-fs- se-ff-" id="SE-89cc9bb2-c289-437b-8b31-103597ee7529" style="">operator overloading에 대한 더 많은 정보는 여기서-&gt;(</span><span class="se-fs- se-ff-" id="SE-d6ecc25e-8b72-4e8d-bcf1-8298beec874d" style=""><a class="se-link" href="https://stackoverflow.com/a/4421719" target="_blank">https://stackoverflow.com/a/4421719</a></span><span class="se-fs- se-ff-" id="SE-a8430966-e86a-4f30-823f-299eb8803ede" style="">)</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-72049c43-05e8-498e-a327-089f2eb03e0c" style=""><span class="se-fs- se-ff-" id="SE-6d554e49-3cd4-4f95-b19c-6a85bf44cd95" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7d79b59e-be99-4cee-be37-d0447106559f" style=""><span class="se-fs- se-ff-" id="SE-75386f2e-7350-499b-a2ac-8492dad6c498" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-90ada14a-3a52-4b8f-a1b0-057a52efd56e" style=""><span class="se-fs- se-ff-" id="SE-cfd6f00a-2c63-44ff-9b38-64e03c019383" style="">Ch.16. Building some useful classes</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-23d1c402-bc0a-4d3c-9310-f899ef219650" style=""><span class="se-fs- se-ff-" id="SE-e7e4c86e-02b9-418e-9f4b-bb420496cef2" style="">- 생략</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b9cbdde2-3306-48d0-be89-30b82883deb2" style=""><span class="se-fs- se-ff-" id="SE-9b81c75f-c92d-48fe-9954-94024e336b63" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7d225556-7953-4b04-a229-5a77b5beecfa" style=""><span class="se-fs- se-ff-" id="SE-7314e1a6-b3f8-42e4-8a20-14a81c5d2b11" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2b24c1bd-3ed0-4fde-8f11-62fe5c6c1524" style=""><span class="se-fs- se-ff-" id="SE-8fbffbea-224c-4abe-80ce-855f661bbc21" style="">Ch.17. Inheritance and polymorphism</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-63cb63a3-2902-49ab-8756-96e852286dc5" style=""><span class="se-fs- se-ff-" id="SE-894d1f00-c1a5-42bf-ad6c-8066c5fbd8b8" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e0bc9c1f-3ea7-4a98-bfe7-46b1e0dedffa" style=""><span class="se-fs- se-ff-" id="SE-cd749746-797c-474d-92c4-c03160aed86b" style="">Inheritance</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-229f0783-8bff-44c2-a538-969ae9e779d0" style=""><span class="se-fs- se-ff-" id="SE-825a683a-5e1a-469a-9e6d-dbbc7f5cadcd" style="">상속은 is a 관계로 표현될 수 있다. 인간 is a 동물. 이때 무엇이 derived class고 무엇이 base class일까?</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7776df82-f447-41b0-9f05-5722481bcd99" style=""><span class="se-fs- se-ff-" id="SE-8a03da20-e8ef-483a-b532-2e3d64c28029" style="">인간이 derived class다. 동물에서 인간이 파생되었기 때문에다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-fb26c63f-3770-4b96-9880-21ed536dd1c8" style=""><span class="se-fs- se-ff-" id="SE-b0129576-b6f6-41a6-b626-9df538a8b5dd" style="">즉 derived class is a base class이다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7021591d-0de9-4f7b-b545-f97719437a61" style=""><span class="se-fs- se-ff-" id="SE-c42d3008-d737-4cca-a490-d84d23c5fcc0" style="">derived-&gt;base. 이렇게 화살표로 나타낼 수 있는데, 이것은 derived가 base에 포함되어 있다고 이해해도 된다. 그렇기 때문에 derived is a base가 성립하는 것이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ca094f54-0449-48b7-a097-ff4031c9ecbe" style=""><span class="se-fs- se-ff-" id="SE-11a0c7c0-26ec-45cd-b7ba-986cf25d75f5" style="">그러나 derived class는 base class를 상속받았고, 더 많은 정보가 추가되었으니 derived class가 base class를 포함하는 것이 아닌가?</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d49f1f73-05cb-43ed-9e53-4819420aebfa" style=""><span class="se-fs- se-ff-" id="SE-a61a7ba1-524d-4a16-9400-de92cf5debfa" style="">아니다. derived class는 base class보다 더 많은 정의들을 가지고 있다 보니 그 class가 구현할 수 있는 대상이 줄어드는 것이다. 즉 인간은 동물의 정의에 더 많은 정의들을 가지고 있으므로 더 적은 부분집합을 가질 수 밖에 없는 것이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9289c872-70ea-4021-8cd2-9f908fda8757" style=""><span class="se-fs- se-ff-" id="SE-17d65b52-2808-4dcb-b652-f6c6ec32a520" style="">Base b; Derived d;에서 b=d;는 되지만 d=b;는 되지 않는다. 그 이유는 assignment operator는 associativity가 right에서 left이기 때문에 대입이 오른쪽에서 왼쪽으로 된다. 따라서 대입되는 방향이 왼쪽이 되므로 b&lt;-d가 맞고, d가 b에 포함되어야 하므로 b=d만 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-186287bb-4338-4164-889b-e9c4e1f321cc" style=""><span class="se-fs- se-ff-" id="SE-57512f01-046f-40b6-bd86-5843ea6aed32" style="">구체적인 이유는 d가 b에 비해 더 많은 정의를 가지고 있는데 b에 d의 정보가 할당될 때 b의 정의만 남겨둔 채로 나머지 정의들은 다 버릴 수 있기 때문이다. 반면 d=b;를 하게 되면 b의 정의가 d의 정의를 다 충족시키지 못해 오류가 뜬다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e2b5f1c0-72e8-4b33-95ea-669fc95b477b" style=""><span class="se-fs- se-ff-" id="SE-5e6f2fe0-5b5b-4068-a9e6-626fda98d7f0" style="">b=d;는 되지만 d=b는 안되는 것을 upcasting이 된다고 하고, downcasting이 안된다고 한다. 그 이유는 base class가 위에 있다고 생각해서 그런 것 같다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2ef80bcc-bc42-401a-8166-090e3111e14b" style=""><span class="se-fs- se-ff-" id="SE-283883bf-47a1-4672-8dd8-9483ba35a02b" style="">class B {}; class D : B {}; 하면 자동으로 private으로 상속됨. class D : public B1, public B2 {}; public으로 선언할꺼면 이렇게 해야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-20441f4f-de58-4530-b762-0447d17d78c9" style=""><span class="se-fs- se-ff-" id="SE-71f02b0c-c9a7-4f65-930f-17d3ae3c43d4" style="">상속은 한 방향으로 밖에 움직이지 않는다. class D는 B의 method를 물려받지만 class B는 D의 method를 물려받지 않는다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c57085e0-b04a-4823-ae87-84c97e24f910" style=""><span class="se-fs- se-ff-" id="SE-2e24ad77-b1b2-471d-98ea-92018cf387c7" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e12b6c3c-a6dd-4f81-9fd4-c8154d49bb5a" style=""><span class="se-fs- se-ff-" id="SE-db399070-1f08-4e51-b715-40b593be8bc7" style="">Polymorphism</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ede24ee1-8fb3-40eb-814a-c961e22e37fa" style=""><span class="se-fs- se-ff-" id="SE-86f53c3c-7331-419a-b31e-3938513a9f7a" style="">Base와 Derived class가 있다고 하자. virtual method가 pointer에 의해 invoke되지 않는 이상(포인터를 사용하지 않고 일반 Base/Derived object 사용하거나, 포인터를 사용하여 virtual method가 아닌 method를 부를 때), static binding/early binding이 된다. 이 static binding은 virtual 함수를 썼을 경우를 보면, 어떤 class의 override된 함수를 호출했는지 확인하고 compile된 위치로 이동한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2b6431c8-aa1e-48f9-99de-b25816addd86" style=""><span class="se-fs- se-ff-" id="SE-8a447d90-832f-47bf-8c7e-b13d810697f5" style="">그러나 virtual method가 pointer에 의해 invoke되면 컴파일러가 아닌 실행 프로그램이 어떤 코드를 실행할지 결정한다. 이 process를 dynamic binding/late binding이라고 한다. 만약 동적 바인딩이 일어나지 않았다면, 즉 정적 binding은 compiler가 모든 변수의 자료형을 기억한 다음에 그 자료형의 method가 compile된 기계어를 찾아가 그 자료형의 함수를 호출한다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-dd8eee4b-2e6c-4df3-8126-fe35148c4aa0" style=""><span class="se-fs- se-ff-" id="SE-70c40c0a-fc87-4f70-8783-a4c913c126e4" style="">그러나 상속과 is a 관계는 일을 더 복잡하게 만들었다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5e8d500a-e8a1-4ca9-991b-03c7edb108e9" style=""><span class="se-fs- se-ff-" id="SE-39ccecf4-1e16-4cb2-bc74-9e7f1a13f4f7" style="">Base *p_b, *p_d, b(initialized); Derived d(initialized); p_b = &amp;b; p_d = &amp;d; 이때 overiding된 virtual method를 사용했을 경우 (p_b-&gt;func(), p_d-&gt;func()), 둘 다 같은 Base 형 pointer임에도 불구하고 다른 값이 나온다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-cd45c793-085a-4f04-a2ee-b4949632ac05" style=""><span class="se-fs- se-ff-" id="SE-0b30cb1a-929b-459a-a6eb-83f10cf4082c" style="">그 이유는 다음과 같다. 만약 class가 적어도 하나의 virtual method를 가지고 있다면, 그 class의 instance는 한가지 hidden field(data member)를 갖게 된다. 그 hidden field는 virtual method pointer 배열을 가르키는 pointer라고 한다. 이거를 vptr이라고 밑에 사이트에서는 부르고 있다. 이 vptr은 vtable(virtual method pointer들의 배열)을 가르키고 있다. 컴파일러는 class의 virtual method에 index를 배정한다. 그리고 vtable[0] = get(), vtable[1] = append() 처럼 index를 배정하는 것이다. 따라서 p_b-&gt;get();을 하면 p_b-&gt;vtable[0]();을 호출하는 것과 같다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c30c7b33-a43e-415b-8407-f2360f038f88" style=""><span class="se-fs- se-ff-" id="SE-f9f607f3-9bb3-453f-bbb4-1eef668ba97e" style="">따라서 p_b = &amp;b; p_d = &amp;d; 했을 경우에, b,d 객체는 이미 vptr를 가지고 있었고, p_b = &amp;b; p_d = &amp;d; 과정을 통해 d의 시작 주소가 p_d로 갔고, p_d에는 d의 vptr field도 가지고 있기 때문에, 같은 Base형 포인터임에도 불구하고 다른 결과가 나온 것이었다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-52527a86-7cdd-4f5e-983e-180d2a3e6daa" style=""><span class="se-fs- se-ff-" id="SE-f683a2f0-56c6-4ac0-9717-609f86c98296" style="">더 많은 정보는 여기서: (</span><span class="se-fs- se-ff-" id="SE-d220f257-6644-4f2f-b090-fe8b5cf31940" style=""><a class="se-link" href="https://www.geeksforgeeks.org/virtual-function-cpp/" target="_blank">https://www.geeksforgeeks.org/virtual-function-cpp/</a></span><span class="se-fs- se-ff-" id="SE-d1704802-7664-4e96-bcd2-10a691c51571" style="">)</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-552f9a76-6aab-420e-a087-18282f1ff582" style=""><span class="se-fs- se-ff-" id="SE-9bfb9abb-baf3-421d-8537-ce4dd14b82e7" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-cc8fda57-20da-411a-a382-0e0ad5110e67" style=""><span class="se-fs- se-ff-" id="SE-0ba9c1a8-8c8c-4976-88b1-7a0b462e98df" style="">Virtual</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9cfed8fa-1ddd-47f2-aad3-a79306b1c5e8" style=""><span class="se-fs- se-ff-" id="SE-5c7a5848-717d-4d23-8a13-06eac0de515d" style="">virtual keyword는 파생 class에서 새롭게 정의하는 것을 class designer가 계획하고 method에 쓰는 것이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-adbb7f3e-7e2c-4178-acbb-3447e4f5e3c7" style=""><span class="se-fs- se-ff-" id="SE-1df705cc-6527-4697-9b96-6347561acc96" style="">순수 가상 함수는 반드시 정의되어 있어야 한다. 선언만 있을 경우 error. 따라서 빈 괄호 {} 라도 적어주어야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-327ee845-c0bb-4b75-a855-90b02ae49f1f" style=""><span class="se-fs- se-ff-" id="SE-a0d04acd-1a55-431c-bf81-ae22b456912e" style="">순수 가상 함수가 아닌 모든 가상 함수는 반드시 derived class에서 구현될 필요가 없다. (</span><span class="se-fs- se-ff-" id="SE-1e6f3aac-2a86-46e4-9454-7c4fe49a6dd8" style=""><a class="se-link" href="https://stackoverflow.com/a/8931719" target="_blank">https://stackoverflow.com/a/8931719</a></span><span class="se-fs- se-ff-" id="SE-92a7ff23-fbe3-4594-accd-c90d170e4cea" style="">) </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f573b1c4-7069-4894-8473-9043a5cc8cd7" style=""><span class="se-fs- se-ff-" id="SE-8aa157da-5e48-4f96-aa2b-511b71de99b4" style="">순수 가상 함수(pure virtual functions/methods)는 virtual void func() = 0; 형태로, 함수(선언) = 0; 형태로 쓴다. 순수 가상 함수가 한개라도 들어가는 class를 abstract class, 추상 class라고 한다. 반면 순수 가상 함수가 하나도 들어가지 않은 class를 concrete class라고 한다. 이 추상 class는 자신의 instance를 절대 만들 수 없다. 그 이유는 이 추상 class는 하나의 abstract concept이기 때문이다. 즉 하나의 추상 컨셉/아이디어이기 때문이다. 이렇게 추상 클래스를 c++에서는 정의한 것이다. 따라서 순수 가상 함수를 쓴 추상 클래스를 상속받는 derived class는 반드시 이 함수를 override해 주어야 한다. 안그러면 오류가 난다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-10b9ce11-c454-4b73-8ac5-1f4925b26ac8" style=""><span class="se-fs- se-ff-" id="SE-72a2b808-d009-40d9-817b-e3659438e5fe" style="">더이상 virtual 함수를 override하지 않게 하려면 override 대신 final을 쓰면 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-8988db96-834b-48ce-a55e-5645998d8bde" style=""><span class="se-fs- se-ff-" id="SE-2ec8f44d-31e4-48ab-b4bf-de5f49c7173d" style="">override나 final은 context-sensitive keyword다. method에 header 부분에 쓰이지 않는 이상 보통 식별자로 사용될 수 있다는 의미다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-42cd5cec-302c-4419-95eb-682a2e0a2295" style=""><span class="se-fs- se-ff-" id="SE-9dc1789a-1403-4544-9f55-3d9a698e0bb4" style="">override를 쓸 때면 virtual keyword를 같이 써도 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4bb568fd-370a-4f79-991e-59f53023c25d" style=""><span class="se-fs- se-ff-" id="SE-36e09f09-2a94-4bbe-a660-5682af2c4eff" style="">override나 final의 사용은 선택사항이다. C++11 이전에는 그냥 계속 virtual keyword를 통해 override를 했다. 그러나 만약 base class에 있는 함수의 signature와 다르게 base class에 적었다면 그 함수는 overriding 되지 않고 overloading이 된다. 이게 골치아픈 문법이 있는 것 같긴 한데, 어쨋든 이걸 방지하기 위해 override가 나온 것이다. override를 쓰게 되면 base class에서 함수 signature를 잘못 쓰더라도 error가 뜨게 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ba0ee3ca-7a92-46d7-810b-b67e9c1355a4" style=""><span class="se-fs- se-ff-" id="SE-55fc443c-45b7-40ac-9580-32377108fb38" style="">base virtual method를 override 할 때면 virtual keyword를 사용하지 않아도 된다. 그러나 이 방법은 권장되지는 않는데, 그 이유는 이게 virtual method인지를 확인하려면 base class를 봐야 하기 때문이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-052b6e12-ec93-4eca-bbd6-f4d560017ea0" style=""><span class="se-fs- se-ff-" id="SE-190beec3-6d46-4add-ad64-6ce4ee25a25f" style="">B라는 class의 method에 virtual std::string get() const; 선언할 때만 virtual keyword를 사용해도 된다 (virtual std::string get() const {};인 구현 부분에서는 사실 virtual keyword를 생략해도 된다.) override 도 virtual과 마찬가지로 선언할 때에만 사용해도 된다. method를 정의할 때에는 생략하고 사용 가능하다는 뜻.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-dd882f9a-1ac7-4d9b-8473-9f04fa4ed90b" style=""><span class="se-fs- se-ff-" id="SE-08302b98-79b7-46c7-a6fa-39a154495299" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4a2c4191-e6af-4429-ae8c-b8798c2350b9" style=""><span class="se-fs- se-ff-" id="SE-31d3f00e-7e54-4f07-b491-a446fca7db32" style="">function overriding이 function overloading이 된다?</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-80c28462-345b-4204-9ea0-6e57ccda5979" style=""><span class="se-fs- se-ff-" id="SE-305d1c09-f0f7-45e6-a959-a0db9f05bce2" style="">base class에 있는 함수를, derived class에 함수 이름은 갖고 signature는 다르게 overloading하면, derived class instance를 통해 접근할 경우 base class에 있는 method는 숨겨진다. 이때 base/derived class의 method는 virtual/non-virtual 다 상관없다. (virtual or non-virtual method in base class gets hidden when overloading virtual or non-virtual function in derived class)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ff98b80b-6c0b-4da4-9b52-a25ba94a8a94" style=""><span class="se-fs- se-ff-" id="SE-2dc654be-2e2b-4d1b-90d9-45721dbe9612" style="">구체적인 설명: (출처: </span><span class="se-fs- se-ff-" id="SE-bac581ab-b660-4f6b-a3c8-e7cc15651c8b" style=""><a class="se-link" href="https://stackoverflow.com/a/8816835" target="_blank">https://stackoverflow.com/a/8816835</a></span><span class="se-fs- se-ff-" id="SE-6fc256ac-330e-4a61-9bd2-8b78a34c5f06" style="">) Base class의 public method void func(double b) {};가 있다. public으로 파생된 Derived class의 private method void func(char d) {};가 있다. 이때 두개의 함수는 모두 virtual이던 아니던 상관 없다. 이때 Derived* d = new Derived(); Base* b = d; 이때 b-&gt;f(65.3);는 func(double b)를 호출하고  d-&gt;f(65.3);는 func(char d)를 호출한다. 이유는 무엇일까? func(double b)는 private으로 상속받고 base class에서도 private으로 정의되었으면,  func(char c)와 같이 base class에서 접근이 가능했을 것이고, function overloading이 일어나야 될 것 같다. 그래서 b-&gt;func(65.3)은 func(double b)를 호출하는 것이 맞지만, 65.3은 double이라 b-&gt;func(65.3)은 func(char d)를 호출할 것 같기 때문이다. 그러나 derived class에서 함수 이름은 갖고 signature가 base class와는 다르게 정의하게 되면 base class에 있는 method는 숨겨지게 된다. (비록 base class에 있는 method가 virtual이 되어서 overloading이 될 것 같아도 말이다.) 이것이 왜 그렇게 되는지는 잘 모르겠지만, 어쨋든 문법이니깐 외워야 할 것 같다. </span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d1d5ce68-10b6-4a59-8d57-e5c7692efbcb" style=""><span class="se-fs- se-ff-" id="SE-8d50bd66-b881-4c55-aa06-59b76ae267ae" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5a7a9b5f-d048-45fc-af34-027ddbeb614b" style=""><span class="se-fs- se-ff-" id="SE-267b033a-ca8a-4112-ae63-9d81f630089b" style="">Public, protected, private - access specifiers, access modifiers</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-01d1bedb-85db-4987-aa06-45f91441e139" style=""><span class="se-fs- se-ff-" id="SE-07a7d740-e0c7-4314-ad2a-e38e47610042" style="">Base class가 있고 1) public으로 Base class를 상속받은 class Derived가 있다고 하자. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c54b1155-a3db-4bfa-a7e0-bb105573a37c" style=""><span class="se-fs- se-ff-" id="SE-d55b838c-b8b9-4e74-9c86-eb7d2c217f29" style="">private: Base class의 member에 private 접근 지정자를 씌우게 되면 그 member들은 derived class 밖에서 접근할 수 없고, derived class 내부에서도 접근할 수 없다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-04a16a21-2390-47b8-8d6b-5944f6af37bb" style=""><span class="se-fs- se-ff-" id="SE-fa5e625c-0bfa-42ab-aae1-c92bd7d5475d" style="">public: Base class의 member에 public 접근 지정자를 씌우게 되면 그 member들은 derived class 밖에서도 접근할 수 있고, derived class 내부에서도 접근할 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a7ef719e-ea93-4064-b1dc-204c076692cc" style=""><span class="se-fs- se-ff-" id="SE-fa5f5d18-9ec1-48a4-bc43-3a27fb0f029d" style="">protected: Base class의 member에 protected 접근 지정자를 씌우게 되면 그 member들은 derived class 밖에서 접근할 수 없지만, derived class 내부에서는 접근할 수 있게 된다. 즉 protected는 inheritance를 위해 private과 public 접근 지정자를 섞어서 만든 접근 지정자다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-dcb2f85a-9815-4477-8b49-ae93fa0a60a6" style=""><span class="se-fs- se-ff-" id="SE-34f84275-a0e9-44a2-8a15-6c725d4ff406" style="">2) 그렇다면 Derived class에 protected로 Base class를 상속받은 경우는 어떨까? </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7a457c08-80bb-4be6-830a-f44ccd22c122" style=""><span class="se-fs- se-ff-" id="SE-6fcd1696-dae5-40f0-b18d-a31d306e4dce" style="">그 경우 모든 public과 protected으로 선언된 Base class의 member들이 Derived class 내에서는 접근 가능하지만, derived class 밖에서 접근할 수 없게 된다. 여기서 base class에 member들이 모두 private, protected로 설정이 되어있을 경우, public/protected base class를 상속받는 것은 같은 효과를 낸다. 그러나 특별한 점은 base class의 member가 모두 public으로 설정된 경우다. 이때 public이 아닌 protected로 상속받게 되면 derived class 외부에서 접근할 수 없게 되는 반면 derived class 내부에서는 접근할 수 있게 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2fc2d6ca-1f0c-4503-90dc-5b1cd5ab9fbe" style=""><span class="se-fs- se-ff-" id="SE-f280d6e3-52c9-4de6-a22c-ba9a8b3e5a3c" style="">3) 그렇다면 Derived class에 private으로 Base class를 상속받은 경우는 어떨까?</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d717b1b9-252a-4ac2-89a4-f022544d383d" style=""><span class="se-fs- se-ff-" id="SE-8a492058-900b-402b-8eaf-f11f9ca34382" style="">그냥 base class를 public/protected/private 어떤 접근 지정자를 사용했던지 derived class 외부/내부에서 모두 접근이 불가능하다. 과연 쓰일 일이 있을까 생각이 되긴 하긴 하는데 밑의 사진 링크에 보면 쓰이는 곳이 있을 수는 있는 것 같다.</span></p></li></ul><!-- } SE-TEXT -->
</div>
</div>
</div>
</div> <div class="se-component se-image se-l-default" id="SE-adfce116-ee93-4372-a81c-b0b02fb48f37">
<div class="se-component-content se-component-content-normal">
<div class="se-section se-section-image se-l-default se-section-align-" style="max-width:210px;">
<div class="se-module se-module-image" style="">
<a class="se-module-image-link __se_image_link __se_link" data-linkdata='{"id" : "SE-adfce116-ee93-4372-a81c-b0b02fb48f37", "src" : "https://www.bogotobogo.com/cplusplus/images/private_inheritance/class_inheritance_diagram.png", "originalWidth" : "210", "originalHeight" : "275", "linkUse" : "false", "link" : ""}' data-linktype="img" href="#" onclick="return false;" style="">
<img alt="" class="se-image-resource" src="https://www.bogotobogo.com/cplusplus/images/private_inheritance/class_inheritance_diagram.png">
</img></a>
</div>
<div class="se-module se-module-text se-caption"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0150317a-4dbd-4bde-bb0d-26204d374c92" style=""><span class="se-fs- se-ff-" id="SE-da8e95c8-c2c4-4c1b-9a20-301131f7fd6e" style="">출처: </span><span class="se-fs- se-ff-" id="SE-4f6afbec-b31f-43c9-9ef3-19268a43a6ee" style=""><a class="se-link" href="https://www.bogotobogo.com/cplusplus/private_inheritance.php" target="_blank">https://www.bogotobogo.com/cplusplus/private_inheritance.php</a></span></p></div>
</div>
</div>
</div>
<div class="se-component se-text se-l-default" id="SE-0a5d0f25-2426-48e8-944d-a9c80333f9b8">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<!-- SE-TEXT { --><p class="se-text-paragraph se-text-paragraph-align-" id="SE-6924f3fc-8e98-4963-8a62-db7ed9f33c41" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-661ccf09-0632-4146-9e9c-842c7cec941a" style="">(P.S. access specifier는 class level에서 작동한다. object level에서 접근 지정자가 작동한다고 생각하지 쉽지만 말이다. 출처: </span><span class="se-fs- se-ff- se-weight-unset" id="SE-820a0e0a-cd4f-494a-9a9d-943f2a863d88" style=""><a class="se-link" href="https://stackoverflow.com/a/17721201" target="_blank">https://stackoverflow.com/a/17721201</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-78aee731-b6c0-4b44-996e-632596abbbdb" style="">)</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-129d1700-3f93-4b5c-8d91-b88c132f4b13" style=""><span class="se-fs- se-ff-" id="SE-66ba13d5-4abb-498a-a721-23132393fdc9" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a6b9095e-ddcd-4eaf-87e2-07b23f1765a7" style=""><span class="se-fs- se-ff-" id="SE-a72b9cb6-a92b-4491-b41e-e935a44607b9" style="">Alternative to inheritance and polymorphism</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a6bc7163-76f3-4bd0-8386-33ae65fd9fd3" style=""><span class="se-fs- se-ff-" id="SE-8035a30b-ba29-4192-9c8c-4ccf7970b16e" style="">상속과 다형성의 장점은 std::vector&lt;Base *&gt; vec; 형태로 vector를 만들고, class Derived1, Derived2, ...등에 상관없이 vec.push_back(&amp;derivedObject)를 할 수 있다는 것이다. 그걸 통해 base class에 적당한 virtual function이 있으면, 그것을 통해 모든 class instance를 제어할 수 있는 것이다. 예를 들어 terran 종족만 모두 갑자기 소리를 지르게 하고 싶을 때, 상속과 다형성을 이용해 그렇게 만들 수 있을 것 같기도 하다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9a9f97e2-ada5-48b1-99a5-ad590dba84da" style=""><span class="se-fs- se-ff-" id="SE-e92ea17f-c63f-4161-b13c-c7ed5354152c" style="">따라서 상속과 다형성의 장점은 포인터에(ptr 크기: 4byte, 32-bit 운영체제)에 더 많은 정의를 담고 있는 자식 클래스의 정보를 다 담을 수 있다는 것에서 나온다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-87c73b7f-484c-4519-afb5-0746457c3ef7" style=""><span class="se-fs- se-ff-" id="SE-a2662d22-8da5-4b18-892d-55f44f325ef5" style="">만약 그러지 않는다면 derived class의 나머지 field를 slice할 것이다. 따라서 포인터 배정이 slicing 문제를 avoid해 준다는 것을 알 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1ef442ae-08f8-4898-a8a4-56d605fee62b" style=""><span class="se-fs- se-ff-" id="SE-c49f5cf1-d274-4670-bd9c-b5e4ac1a505a" style="">그러나 사실 상속과 다형성을 대체할 수 있기는 하다. 그런데 그걸 하려면 비교적 안좋다. 상속과 다형성을 회피하여 만든 프로그램과 비교했을 때 상속과 다형성을 사용한 프로그램이 더 좋은 이유를 알아보자.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-cd320703-f128-417c-a5c2-db483a958606" style=""><span class="se-fs- se-ff-" id="SE-b2156988-97aa-4c92-8954-c3d7ddd4b5fd" style="">1) 각각의 derived class들이나 base class는 추가적인 field를 가지지 않는다. memory를 아낄 수 있다는 것이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a86cef7b-e491-4eda-9dc3-cf7345417931" style=""><span class="se-fs- se-ff-" id="SE-ec14eb83-8876-4f27-ab57-67625f0995ef" style="">2) 새로운 기능을 추가하기 위해 base class를 수정하지 않아도 된다. 오직 base class 하나만 더 만들면 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9359286a-176a-4fd3-ba6c-551ae677b9e1" style=""><span class="se-fs- se-ff-" id="SE-d2f1065d-3a5a-4885-8ad5-4304ed025c2d" style="">3) 모듈화가 가능하다. 이말이 무슨 말이냐면 base class의 header file만 있어도 derived class를 구현 가능하다. 즉 base class의 </span><span class="se-fs- se-ff-" id="SE-3a84ceb3-4754-4d5f-8517-2b4afb68b29e" style=""><b>interface(method 종류)</b></span><span class="se-fs- se-ff-" id="SE-f7d34ecc-cd2b-479f-9f4b-46c3d9740278" style="">만 가지고 있어도 된다. base class의 cpp file은 만약 compile된 파일이 있다면 필요 없다. 그냥 link 과정만 있으면 되기 때문이다. 단 base class를 이용하고자 하는 모든 client는 base class의 header file은 반드시 필요하다. (base class에 virtual 함수가 많아야 가능한 일일 것 같긴 하다.)</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-280ed1fb-0d56-4f91-9818-7f99c932ff7a" style=""><span class="se-fs- se-ff-" id="SE-d6f36e98-11c7-40bd-b57c-ee66c5c8946a" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-bb58a821-6e9e-42cd-9b6b-e27c52fe2616" style=""><span class="se-fs- se-ff-" id="SE-da85a61a-f930-4eb7-a0ea-b009dc9790bc" style="">Adapter design pattern</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-20e920aa-2a25-4452-835b-899dd5475f53" style=""><span class="se-fs- se-ff-" id="SE-8d9354d0-a350-44c7-b950-34e5bb9308a6" style="">만약 class X 와 class Y를 가지고 있고 이 두개의 class가 기능적으로는 거의 비슷한데 interface가 다른 경우(different method), 또는 라이선스 문제가 있는 등의 우리가 class Y가 어떻게 돌아가는지 수정/control할 수 없는 경우 </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-85c1cc04-248d-4e59-affc-9e632d096203" style=""><span class="se-fs- se-ff-" id="SE-ef937623-c71b-489a-bff3-42456236d6f7" style="">class Y를 수정할 수 없어서, class Z를 Y처럼 쓰고 싶다면, 그럴 때 adapter design pattern을 쓰면 된다.</span></p></li></ul><!-- } SE-TEXT -->
</div>
</div>
</div>
</div> <div class="se-component se-code se-l-code_black" id="SE-be545ca5-8cbc-407a-a5ee-9738843e5a52">
<div class="se-component-content">
<div class="se-section se-section-code se-l-code_black">
<div class="se-module se-module-code se-fs-fs13">
<div class="se-code-source">
<div class="__se_code_view language-javascript">class Z : public X {
    Y *ptry; // 포인터를 사용하는 이유는 모르겠다..아마 polymorphism에서 derived class의
             // slicing 문제를 해결하기 위해 그런 것이 아닐까?
public:
    Z(Y* y) : X(....), ptry(y) {} // 생성자
    X/Z의 함수 override {
        Y-&gt;(Y의 methods); // Y의 methods, 왜냐하면 X / Z의 함수 호출로 Y 함수 호출을 하고 싶은 것.
    }
};
// class Z 활용
std::vector&lt;X*&gt; xvec;
Y y;
Z z(&amp;y);
xvec.push_back(&amp;z);
xvec[0]-&gt;(X / Z의 method);﻿</div>
</div>
</div>
</div>
</div>
<script class="__se_module_data" data-module='{"type":"v2_code", "id" : "SE-be545ca5-8cbc-407a-a5ee-9738843e5a52"}' type="text/data"></script>
</div> <div class="se-component se-text se-l-default" id="SE-4a6d86cc-af07-49d2-82be-7c06f220defc">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<!-- SE-TEXT { --><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7d1a4657-15fc-42bf-99af-dfa10c67ecf3" style=""><span class="se-fs- se-ff-" id="SE-4a4ffa00-8245-4a98-b689-bec4e6eb1331" style="">class Z 활용 부분에서는, Y의 함수를 작동시키지만 X의 interface(method)로 작동되는 class Z와 class X를 동시에 관리하기 위해 X형 포인터를 원소로 가지는 vector를 만들고, vector에 class Z instance를 push_back해준다. 그럼 xvec[0]-&gt;(method) 형태로 함수를 동시에 호출할 수 있다.</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a4344ec9-222a-4fbb-964f-266c56258e17" style=""><span class="se-fs- se-ff-" id="SE-65df614b-bc03-4ef7-9831-2ce97c0b66fd" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b0a6321a-0ad4-48a5-93b6-b57738d395f7" style=""><span class="se-fs- se-ff-" id="SE-828ebaf6-3c9f-4dd3-94c3-502f84f218db" style="">Constructor, destructor call sequence</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7d870be8-8c2a-456d-b987-34f46da0939b" style=""><span class="se-fs- se-ff-" id="SE-0749894e-a6f3-4935-b54e-a9a0bc812302" style="">생성자와 소멸자가 호출되는 시기는 언제일까?</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f42ba4e1-6677-4cf9-b5a5-ba98bbd88878" style=""><span class="se-fs- se-ff-" id="SE-6ce9448e-052b-4a60-860a-b3bc9b13f0cd" style="">c-&gt;b-&gt;a 형태의 class가 있다고 해보자. c는 b를 상속받았고 b는 a를 상속받았다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-cd898cb4-f4f1-4368-b650-5fe5b7ab8387" style=""><span class="se-fs- se-ff-" id="SE-fadbed17-19d0-4bd4-a51a-c0e699a1fe3c" style="">이때 생성자는 a,b,c 순서로 호출되고 소멸자는 c,b,a 순으로 호출된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4afd6c16-d6f5-4e53-b9ea-b28ed4334aaf" style=""><span class="se-fs- se-ff-" id="SE-b9d767b6-8ce8-4485-81fe-d66553c60ebd" style="">즉 생성자는 부모부터 호출되고, 소멸자는 자식부터 호출된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-752f74fe-4de2-4681-88b1-7a4b0fec1943" style=""><span class="se-fs- se-ff-" id="SE-e35e2b9a-de28-4ad0-9477-97af13e35379" style="">왜 이렇게 설계되었냐면, 자식 class(sub-class)는 부모의 field를 사용할 수 있기 때문이다. 따라서 부모의 생성자가 먼저 호출되어야 부모의 field가 초기화가 되고, 그래야 초기화된 부모의 field를 자식이 사용할 수 있는 것이다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-220f6dbf-c402-44e8-b4f9-94508d943997" style=""><span class="se-fs- se-ff-" id="SE-bccea9dd-d476-437b-89b4-193f722e46b1" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-476c3c78-181e-43c8-8131-4bed7de8611c" style=""><span class="se-fs- se-ff-" id="SE-c87e2cb3-4573-4fb3-b1c7-4d61c486074a" style="">Constructor, member initializer list</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-455cbafd-6d44-458d-a3d5-8d6a54474b51" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-1cf2c012-7ad8-47dd-afcc-6857e6a99748" style="">Derived class의 생성자에서 Base class의 생성자를 호출해야 하는 경우, 반드시 member initializer list를 이용해 Base class의 생성자를 호출해 주어야 한다. 그 이유는 c++ 문법이 그렇기 때문이다. 만약 이렇게 base class의 생성자를 초기화 리스트를 이용해 derived class의 생성자에서 호출하지 않으면 default 생성자가 호출이 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3f4dceab-6ebe-43c4-916c-f87b545fcaf5" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-9f0da4ef-568a-4d6a-b78b-52b16d331810" style="">또한 초기화 리스트가 아니라 derived class의 생성자 함수 내부에서 생성자를 호출할 경우 그냥 그 함수 scope 내에서 만들어지는 지역 변수가 생성된다. 그러면 base class의 변수는 초기화하지 못하게 된다.(더 많은 내용은 여기서: </span><span class="se-fs- se-ff- se-weight-unset" id="SE-27901b7f-a94b-4f2a-8758-e809fbf3612e" style=""><a class="se-link" href="https://stackoverflow.com/a/7810306" target="_blank">https://stackoverflow.com/a/7810306</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-834eee3b-4c3e-4d99-98ae-15fc81c2e8b9" style="">)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-28c7d0f6-705a-4334-8cea-bf0fa155fa12" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-1394a044-e56d-4033-affe-bdb4317e1bc8" style="">또한 base class의 생성자 호출을 초기화 리스트에서 할 때 초기화 리스트중 가장 먼저 나와야 한다. 그 이유는 문법이 그렇다. 아마 base class의 생성자가 먼저 호출이 되고 다른 derived class의 member가 초기화가 되어야 해서 그런것이 아닐까 싶다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c7ea4a2e-175f-4781-9f15-e8ccaa332beb" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-20681700-a676-4fa5-94ed-682f3f1de85f" style="">member initializer list를 반드시 사용해야 하는 경우: (</span><span class="se-fs- se-ff- se-weight-unset" id="SE-df1a7553-051c-4bb1-aad1-85e642b6435f" style=""><a class="se-link" href="https://stackoverflow.com/a/8523361" target="_blank">https://stackoverflow.com/a/8523361</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-114247ed-6299-4cc6-96b8-1b8b3db0bab9" style="">)</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-65beeabb-3705-4879-8879-8373a3eb8a04" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-f38ede42-60fb-4607-8ada-4a082adacd00" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d965c5ac-cb28-4f12-82fb-10663b2dc9b2" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c7554e7d-a8a5-4823-9875-ff1896c90e28" style="">Copy constructor, assignment operator in classes, shallow / deep copy</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f8a87791-6272-42a5-bacd-3c5361e8a448" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-a5172909-b995-417d-98b4-b506f69ed432" style="">배경:</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-28d38028-095e-46cc-8672-0236225fde61" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-f004afe8-27db-4010-96db-4bae72291476" style="">member 변수로 포인터 변수를 가질 때 명시적 copy constructor가 필요하다. 그 이유는 그냥 대입 연산자를 하게 되면 그 주소값이 포인터로 대입이 되기 때문에 같은 주소값을 가져 같은 곳을 가르키게 되기 때문이다. 이것을 shallow copy라고 한다. 따라서 pointer를 data member로 가지지 않는 경우 copy constructor가 필요하지 않다. deep copy, shallow copy의 개념은 여기서 파생된 것이다. deep copy는 서로 다른 복사본 두개를 만드는 것이고, shallow copy는 서로 다른 포인터 data member가 같은 주소값을 value로 가질때, 실제 변수는 두개지만 1개만 가르키게 만드는 것이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f6f86129-53d0-459f-bd8e-d81231f2b882" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-8e35757e-0421-43d9-b894-922cdd28c61c" style="">따라서 deep copy, shallow copy는 pass by reference, pass by value 개념과 다르다. shallow / deep copy는 (포인터 변수를 member data로 가지는) 객체의 복사에 대한 얘기고, pass by reference / value는 객체의 전달에 대한 얘기다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c52e9953-f4ae-417f-adca-ca03195df432" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-629d16e5-992f-495a-a0a8-b0194b59f01a" style="">만약 어떤 객체를 pass by reference로 보낸다면(passing object by reference), 복사는 일어나지 않는다. 그러나 어떤 object를 pass by value로 보낸다면, 객체가 복사된다. 이때 객체가 포인터가 아닌 변수들만 field로 가지고 있다면 객체 복사는 아무 문제 없이 별개의 객체로 잘 복사가 된다. 그래서 shallow copy와 deep copy라는 개념이 포인터 변수가 아닌 변수에서는 존재하지 않는다는 것이다. 기본 대입 연산자는 member들끼리 단순하게 복사시켜 준다. 이때 포인터인 멤버 변수가 단순하게 복사된다는 것은 포인터값이 서로 복사가 된다는 것이고 따라서 같은 객체에 대한 두개의 포인터가 만들어진다는 것이다. 즉 이 두개의 포인터는 이름만 다를 뿐 같은 객체를 가르키데 된다. 이게 shallow copy다. 대입 연산자는 pointer를 member data로 가질 경우 default로 shallow copy가 된다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ba71b358-546d-45b3-ad9a-13ae5cc028f2" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-ec13398a-a051-4286-821b-0426d52f941a" style="">만약 포인터 멤버 변수가 가르키는 sub-object가 온전히 자신 class의 객체가 되도록 만들고 싶다면 deep copy가 필요하다. deep copy는 pointer를 member data로 가질 경우 복사되는 객체의 포인터 member data가 서로 다른 object를 가르킬 수 있도록 하는 것이다. 왜냐하면 shallow copy는 복사를 하게 되면 복사를 한 모든 객체에 대해 포인터 멤버 변수는 모두 한 sub-object를 가르키게 되기 때문이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-edb446cf-664e-4418-8998-94574e0d5d89" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-a5878ec0-a7fe-4b92-8887-5ab0039d7870" style="">따라서 이를 위해선 custom copy constructor와 custom assignment operator를 구현해야 한다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-42be9838-1ec1-4a74-9d3b-2d6b67133eb9" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-170ce1df-c5d7-480b-99b8-38d00883643a" style="">(참조: </span><span class="se-fs- se-ff- se-weight-unset" id="SE-2f58e1ee-a94e-4e10-aab3-e3036625569b" style=""><a class="se-link" href="https://stackoverflow.com/a/45367718" target="_blank">https://stackoverflow.com/a/45367718</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-065259da-9105-4aa4-9aff-c48e376dde5f" style="">)</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e85ee072-5287-430b-82c4-e9203e457dbb" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-7dfa2881-f54a-4e13-b85f-e8a4cd003076" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9961b86c-b120-403c-b6b3-7a3fea51df68" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-0a1335a6-ced3-4b6b-9a51-7bdc4c28c2c9" style="">(P.S. access modifier,접근 지정자는 class level에서 작동하지, object level에서 작동하지 않는다. 따라서 copy constructor의 parameter의 객체의 private 변수들을 마음대로 접근할 수 있다.)</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c44da22c-8664-4f0b-8ada-12879d72e2b5" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-9ee63307-5e25-4a53-a941-39dbe72f5a0b" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b11c54a0-a00a-48dc-a0dd-bb4ad08b749c" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-a768f6c9-7077-48a4-ac3f-dca170796fa7" style="">문법:</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a3b4d562-3512-4e3d-b6a2-8ff8f1e456a6" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-d7f3fa37-d446-4b12-ba80-daf45a235761" style="">default copy constructor: 복사 생성자를 명시적으로 정의 안하면 묵시적으로 복사 생성자가 정의가 된다. 이 복사 생성자를 default copy constructor라고 한다.이거는 shallow copy다. 왜냐하면 이 default copy constructor는 assignment operator를 overloading한 것과 같은 기능을 보이기 때문이다. 즉 복사 생성자를 명시적으로 정의 안한 상태에서 Derived ob1(ob2);를 하게 되면 ob1 = ob2;와 같은 의미다. 이 현상은 assignment operator를 overloading해줘도 동일한 현상이 나타난다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e65d512f-3e33-424d-b486-62070074f984" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-8cfbbc97-9f72-436d-8f93-55543473ba00" style="">복사 생성자의 문법은 다음과 같다. Derived class 내의 public 부분에 Derived(const Derived&amp; d) { delete []data; data = new int[n]; for (int i = 0;i &lt; n; i++){this-&gt;data[i] = d.data[i]}} (*(this-&gt;data) = *(d.getData());) 라고 정의. (여기서 data는 동적으로 할당된 배열) 여기서 무엇이 중요하냐면 복사 생성자의 formal paramter의 const와 &amp;를 반드시 써주어야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d6e7f379-8e8d-455c-aa63-b86352ad579d" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-8d16813a-0287-44af-b46d-5eaa2563dc38" style="">또한 복사생성자를 명시적으로 정의하게 되면 대입 연산자도 overloading하는 것이 좋다. 그 이유는 대입 연산자로 객체를 복사할 때 deep copy로 하기 위해서다. 대입연산자 overloading 문법은 다음과 같다. Derived&amp; operator=(const Derived&amp; d) {if (this != &amp;d) { delete []data; data = new int[n]; for (int i = 0;i &lt; n; i++){this-&gt;data[i] = d.data[i]}}return *this;} (배열이 아니면 for loop 대신 *(this-&gt;data) = *(d.getData());)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-291a40ba-d6ea-40eb-a583-55ef21033901" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-afc0db84-406d-4310-9822-d2b5f66c0c77" style="">위의 대입연산자 overloading에서 self assignment check을 해야하는 이유: 왜 if (this != &amp;d) {...}를 해야 하는가? 그 이유는 만약 같은 객체 ob1 = ob1;을 하게 되면 어떤 일이 벌어지냐면, 먼저 내부적으로 lvalue인 ob1의 값이 파괴된다. 그 다음 rvalue 값을 lvalue에 대입해야 하는데, rvalue가 파괴되어 logic error가 발생한다. (사실 정확하게 말하면 lvalue인 ob1의 memory를 release해주는 것이다(</span><span class="se-fs-fs13 se-ff-system se-weight-unset se-style-unset" id="SE-abbe404d-b061-4ea8-ae89-a7aa8924fef6" style="color:#4d5156;background-color:#ffffff;">≈</span><span class="se-fs- se-ff- se-weight-unset" id="SE-627e71aa-66b4-4807-af49-c9a45fed8ce8" style="">값 파괴). 왜 그런거냐면, 실제 우리가 overloading하는 assignment operator를 보자. 맨 처음 하는 것이 delete[] data;이지 않는가. 따라서 대입 연산자의 수행은 항상 먼저 lvalue의 delete이 이루어져야 하는 것을 알 수 있다. 참고: </span><span class="se-fs- se-ff- se-weight-unset" id="SE-b4a73867-c02d-4dcc-a02e-ba05bd5d0f47" style=""><a class="se-link" href="https://www.geeksforgeeks.org/g-fact-38/" target="_blank">https://www.geeksforgeeks.org/g-fact-38/</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-e42359ce-9644-4318-b59a-658d6ac1bd8d" style="">) (만약 well-designed operator를 만들고 싶다면, 또는 if condition check를 하지 않고 lvalue의 memory release를 방지하고 싶다면, 지역변수 int *new_data = new int[n]를 만들어서 거기에 대입 연산자의 rvalue를 대입하고, lvalue를 delete한다. 그 다음 this-&gt;data에 = new_data를 해주면 self-assignment check이 필요없이 self-assignment하는 도중 lvalue가 삭제되는 문제가 해결된다. 그러나 이 방법은 performance적으로 좋은 방법은 아니다. 왜냐하면 모든 assignment에 대해 쓸데없는 지역변수가 만들어지기 때문이다. 참고: </span><span class="se-fs- se-ff- se-weight-unset" id="SE-f655d6da-95e6-4b8f-8696-26bbf620fa5a" style=""><a class="se-link" href="https://stackoverflow.com/a/12015213" target="_blank">https://stackoverflow.com/a/12015213</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-57f6953d-a627-4e99-baba-73b5083d4141" style="">)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-239902de-8eb3-4e91-8a72-9ab5ae855075" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-1560c477-1c7d-42cf-a58b-c099b932f06d" style="">복사생성자가 호출되는 경우와 대입연산자가 호출되는 경우:</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-02eb1a68-e453-49cd-bc27-32632e1aff95" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-70ab4d52-c705-4116-9f26-0c2eb663e0ab" style="">1. Derived ob1(ob2); 는 복사생성자가 호출됨. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-bfbaef7c-a9ea-47c2-8acf-e4fb79fba1f2" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-d944a549-913d-4f0d-856e-ee944cf51ba9" style="">2. Derived ob1 = obj2; 는 복사생성자가 호출됨. (copy elision 때문) </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-8abeaa7d-847a-4b2a-a7cc-01af642a38a0" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-b32d8f5f-e32c-4cb5-83de-9e7e7fa4efe5" style="">3. ob1 = obj2; 는 대입연산자가 호출됨.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d69d48af-2237-409b-bd9d-b03f3fce61c0" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-64424c33-b690-4131-9b59-0fce6fdd3578" style="">복사생성자 문법에서, formal paramter에 const를 붙여야 하는 이유는 무엇일까? 그 이유는 (</span><span class="se-fs- se-ff- se-weight-unset" id="SE-e56ad1fe-1848-4271-9414-8e0bb95fd03c" style=""><a class="se-link" href="https://www.geeksforgeeks.org/copy-constructor-argument-const/" target="_blank">https://www.geeksforgeeks.org/copy-constructor-argument-const/</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-4355f710-27c2-416c-9a37-d85fd379ce28" style="">)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d65a2cf5-7ed1-483e-8579-120bc2e1b537" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-37a13d66-a217-48c0-93a2-634bc80cdcb2" style="">이렇게 복사 생성자로 member를 초기화하는 경우 copy initialization이라고 한다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-6c2e5c9c-513b-44b0-847f-0ef0e74c666f" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-3a9a18d0-39ed-4cc4-a233-289e033267e5" style="">copy constructor in cpp(</span><span class="se-fs- se-ff- se-weight-unset" id="SE-0f9768af-731d-476c-9f27-da008a976171" style=""><a class="se-link" href="https://www.geeksforgeeks.org/copy-constructor-in-cpp/" target="_blank">https://www.geeksforgeeks.org/copy-constructor-in-cpp/</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-9c0f8d45-b9c7-4018-8857-1909d966ace9" style="">)</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d7f1b7db-2eee-4959-a6ff-80955e481b34" style=""><span class="se-fs- se-ff-" id="SE-588d69ae-3bc7-4621-bd53-6a2fb8b4d6d6" style="">copy elision in cpp(</span><span class="se-fs- se-ff-" id="SE-a247435b-6a8a-4b7c-97b3-4cf21fb0322e" style=""><a class="se-link" href="https://www.geeksforgeeks.org/copy-elision-in-c/" target="_blank">https://www.geeksforgeeks.org/copy-elision-in-c/</a></span><span class="se-fs- se-ff-" id="SE-63e96031-1f56-415d-928c-c7c092d7ce19" style="">)</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-936bcbab-ab4d-42bf-a491-a6755279b044" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-eff1198a-205e-4d91-a5ad-e25be561a8c7" style="">copy elision and return value optimization: (참고: </span><span class="se-fs- se-ff- se-weight-unset" id="SE-357d1fd4-312c-48f9-851b-1640c8cb0892" style=""><a class="se-link" href="https://stackoverflow.com/a/12953129" target="_blank">https://stackoverflow.com/a/12953129</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-b7ce1e45-1295-4163-9d9d-af3aa2ec7b13" style="">)</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ff180d9a-6ef1-47fd-a173-ad06d3a365de" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-3503769d-1ac2-4d16-aab9-84ebbc8be050" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-80e17cc1-f4c1-4090-b456-0cc65041a9d2" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-6f0d82b2-e8a9-4ef4-be66-566f67b46325" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-071618a4-d8db-44a4-a75f-9f660ee4d52b" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-2741088e-17b9-480e-a835-71fa709df898" style="">Ch.18. Resource management</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-10afc1af-c1f7-4d3f-bbd5-6ae2a5c1eba0" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-79b5136f-54c9-4e8e-95d7-387ce3b767b0" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7e7a5ee5-482f-4554-acfc-1f01e01420a0" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-dcb30090-3e64-4a7e-aedd-13aba6454a2b" style="">code, data, heap, stack</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-783b515b-d8ed-478b-a941-d76b3448abf1" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-79983bc7-fe51-4a0c-9537-984f46e4e3fd" style="">memory는 4개의 영역으로 나뉘어져 있다. code, data, heap, stack이다. Data는 global variable과 static(persistent local variable) variable을 갖는다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-cf3c301f-14b8-45e5-806b-977eccda2fde" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-72d9ec3f-61c6-47aa-b655-d8d171586c27" style="">1. code는 executable instruction를 가지는 memory부분이다. code section의 content는 실행되면서 절대 변경되지 않아야 하며, code segment의 size도 프로그램 실행과정에서 변하지 않는다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e5827f43-2d4f-4e3b-a4de-2f2424d13ea4" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-303dc9f4-dcc7-49db-b92d-4a2d975876da" style="">2. 메모리의 data section은 global variable과 static(persistent local variable) variable을 갖는다. 이 변수는 프로그램 실행이 끝날 때까지 data section에 존재한다는 특징이 있다. 변수가 const가 아닌 이상 그 값을 자유자제로 바꿀 수 있기 때문에, data section의 content는 실행되면서 변경될 수 있지만, data segment의 size는 변경되지 않는다. 이것을 할 수 있는 이유는 프로그램의 소스 코드가 global/static 변수의 개수를 정의하기 때문에, data segment의 정확한 size를 compiler가 계산해낼 수 있기 때문이다. global 변수는 run-time environment에서 main 함수가 실행되기 전에 초기화가 되고, main함수가 return될 때 치워진다. static 변수는 static이 들어있는 지역에서 function/method의 첫번째 invocation에서 초기화되고, main함수가 return될 때 치워진다. 반면 non-static local variable들은 함수가 실행될 때에만 stack에 저장된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-cbe4c8ee-0f0f-4cc4-aa49-f57b657d0d0b" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-8b648cfe-725f-4057-bcb8-1d1c4aa3e469" style="">3. heap: new keyword는 heap으로부터 메모리를 가져오고, delete는 할당된 메모리를 heap으로 다시 돌려 보낸다. heap의 size는 동적 메모리를 new/delete를 활용해 allocate/deallocate 하느냐에 따라 자라기도 하고 줄어들기도 한다. heap space는 보통 stack보다 크다. OS가 가상 메모리를 사용하여 시레 메모리보다 큰 메모리를 실행 프로그램이 사용할 수 있다. 가상 메모리는 disk drive로 부터 오는데, 이거는 속도가 느리다. vifrtual memory는 unlimited하지만, memory leak이 발생하는 프로그램이라면 언젠가는 메모리가 부족할 수 있다. heap은 new와 delete로 grow/shrink하는데, new로 새롭게 메모리를 할당한 순서와 다르게 delete할 수 있다. 따라서 heap 공간은 contiguous하지 않다. 그렇기 때문에 heap에서 사용 가능한 memory는 프로그램 실행 동안에 fragmented 될 가능성이 높다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5333b797-b45c-4e7f-8079-f86bf6e9a5f2" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-53baee94-0b54-49d6-8870-8290179d86bb" style="">4. stack: 지역변수와 함수 parameter가 사는 곳이다. OS는 stack의 size를 limit한다. 무한 recursion을 예로 들면 stack의 공간을 모두 잡아먹을 것이다. 이 현상을 stack overflow라고 한다. Modern OS는 stack space를 다 잡아먹으면 process를 중단시키지만, embedded system에서는 stack overflow는 발견되지 않을 수 있다. 따라서 heap 공간이 stack보다 공간이 보통 더 많다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e0e8b118-228f-4d63-ad56-a4789f91ad13" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-42fe77c3-dd4d-4431-aa8a-cb6a1e5b52f8" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e531df3f-bc02-4323-9706-f3afbd50ff30" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-31fb797c-64af-41db-a826-be731f336af4" style="">new, delete 쓰는 방법</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-11f680fe-f335-4b79-8f0f-ac3d97677ff0" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-09385612-318a-4997-9638-80fe7734d1de" style="">모든 new 명령어 사용 뒤에는 더 이상 할당된 메모리가 필요 없어지면 delete를 사용해야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-81a3d673-b951-4f37-bc0e-5cbe9fdf96a3" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-9999b409-9f62-46e1-8b98-dd10b48a4aad" style="">calc 함수 안에 new가 있는 경우 함수 안에서 delete를 사용하지 않고 run-time error가 일어나지 않게 하는 방법은 총 2가지가 있다. 1. 첫번째는 할당된 메모리에 global 또는 static local pointer를 할당한다. 이 방법은 main함수가 return 될 때까지 살아있으므로 우리가 delete할 필요가 없는 것이다. 2. 두번째 방법은 p를 return하여 function caller가 calc이 만들어낸 object를 다 썼다면 caller가 return할 수 있도록 하는 것이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ba7097d9-3971-4eee-a4e5-0a8954118ad0" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-cef69373-6c72-4833-96dc-b61a4bc4149d" style="">delete operator는 new로 할당되지 않은 pointer에 사용되면 안된다. -&gt; 이거는 undefined behavior라서 logic error.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ad44e1f4-aff0-4bf5-acdc-04e1614cd031" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-46b5e2ea-703d-4972-bc8a-8c624ac25653" style="">같은 메모리 공간에 delete를 두번 이상 사용하면 안된다. -&gt; 이거는 undefined behavior라서 logic error.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-96c5db99-3f59-405b-af9e-4834d051c398" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-3fab6665-4558-4cd4-bf91-43d7d1ad794e" style="">이미 delete한 메모리 공간에 접근하면 안된다. -&gt; 이거는 undefined behavior라서 logic error.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4e9567ba-28d8-438a-ad37-bf823eead83b" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-96357e0b-c49d-4f99-b590-f0e05ee793eb" style="">큰 프로그램을 만들다 보면 multiple delete를 방지하기 사실 쉽지 않다. 따라서 memory allocation을 계속 기록하고 있는 하나의 complex global accounting infrastructure를 구현해야 한다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1720fae3-cabf-4e65-847c-af341976c081" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-99afe089-1bd1-426e-bb7f-e0a895b5916e" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0612b609-08ee-4485-8083-b032ad98f0e5" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-fb7a7323-08e4-4ca6-98a1-b986dccec5f7" style="">Linked list</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7b83a0b5-e2f7-49cf-b218-897edaebae72" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-74bff209-be81-4a17-82aa-c30527d14ba7" style="">linked list를 사용하는 client의 main 함수:</span></p></li></ul><!-- } SE-TEXT -->
</div>
</div>
</div>
</div> <div class="se-component se-code se-l-code_black" id="SE-72a612d1-00d5-4e26-9d46-4211435540ea">
<div class="se-component-content">
<div class="se-section se-section-code se-l-code_black">
<div class="se-module se-module-code se-fs-fs13">
<div class="se-code-source">
<div class="__se_code_view language-javascript">#include &lt;iostream&gt;
int main() {
	bool falseIfExitLoop = true;
	int decideWhatToDoWithLinkedList, dataForInsert;
	IntList1 list;
	while (falseIfExitLoop) {
		std::cout &lt;&lt; "-------------------------------\n";
		std::cout &lt;&lt; "0: exit, \n";
		std::cout &lt;&lt; "1: insert item, \n";
		std::cout &lt;&lt; "2: print item, \n";
		std::cout &lt;&lt; "3: get length, \n";
		std::cout &lt;&lt; "4: erase all item\n";
		std::cout &lt;&lt; "Enter: ";
		std::cin &gt;&gt; decideWhatToDoWithLinkedList;
		std::cout &lt;&lt; "-------------------------------\n";
		switch (decideWhatToDoWithLinkedList) {
		case 1:
			// code
			std::cout &lt;&lt; "Enter integer: ";
			std::cin &gt;&gt; dataForInsert;
			list.insert(dataForInsert);
			list.print();
			break;
		case 2:
			// code
			list.print();
			break;
		case 3:
			// code
			std::cout &lt;&lt; "number of elements: " &lt;&lt; list.length() &lt;&lt; '\n';
			break;
		case 4:
			// code
			list.clear();
			break;
		case 0:
			// code
			falseIfExitLoop = false;
			break;
		default:
			std::cout &lt;&lt; "Enter between 1-4\n";
			break;
		}
	}
	list.clear();
}</div>
</div>
</div>
</div>
</div>
<script class="__se_module_data" data-module='{"type":"v2_code", "id" : "SE-72a612d1-00d5-4e26-9d46-4211435540ea"}' type="text/data"></script>
</div> <div class="se-component se-text se-l-default" id="SE-6c07d9c1-1284-4bae-a278-26925d8afc46">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<!-- SE-TEXT { --><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a12693a0-e979-4638-bed9-940c65c7c50e" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-2ee61820-25a3-4151-959e-209ca0201c9b" style="">Linked List version1: IntList1</span></p></li></ul><!-- } SE-TEXT -->
</div>
</div>
</div>
</div> <div class="se-component se-code se-l-code_black" id="SE-0c8b1480-661f-4178-993a-524825354f04">
<div class="se-component-content">
<div class="se-section se-section-code se-l-code_black">
<div class="se-module se-module-code se-fs-fs13">
<div class="se-code-source">
<div class="__se_code_view language-javascript">#include &lt;iostream&gt;
#include &lt;iostream&gt;
class IntList1 {
private:
	struct Node {
		int data;
		Node* next;
		Node(int d);
	};
	Node* head;
	Node* tail;
	int lengthPrivate(Node* p) const;
	void clearPrivate(Node* p);
public:
	IntList1();
	void insert(int n);
	void print() const;
	int length() const;
	void clear();
};

IntList1::Node::Node(int d) : data(d), next(nullptr) {}
IntList1::IntList1() : head(nullptr), tail(nullptr) {}

// clear helper method and clear method
void IntList1::clearPrivate(Node* p) {
	if (p) {
		clearPrivate(p-&gt;next);
		delete p;
	}
}
void IntList1::clear() {
	clearPrivate(head);
	head = tail = nullptr;
}

// length helper method and length method
int IntList1::lengthPrivate(Node* p) const {
	if (p) {
		return lengthPrivate(p-&gt;next) + 1;
	}
	else {
		return 0;
	}
}
int IntList1::length() const {
	return lengthPrivate(head);
}

// print public method
void IntList1::print() const {
	for (auto cursor = head; cursor; cursor = cursor-&gt;next) {
		std::cout &lt;&lt; cursor-&gt;data &lt;&lt; ' ';
	}
	std::cout &lt;&lt; '\n';
}

// insert public method
void IntList1::insert(int n) {
	IntList1::Node* newNode = new IntList1::Node(n);
	if (tail) {
		tail-&gt;next = newNode;
		tail = newNode;
	}
	else {
		head = tail = newNode;
	}
}
</div>
</div>
</div>
</div>
</div>
<script class="__se_module_data" data-module='{"type":"v2_code", "id" : "SE-0c8b1480-661f-4178-993a-524825354f04"}' type="text/data"></script>
</div> <div class="se-component se-text se-l-default" id="SE-1d7b113b-c5b5-43ea-b4c7-1fb53f74c798">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<!-- SE-TEXT { --><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-041f6192-ca65-43e2-a02f-6e379b3eee11" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-cd1aa440-b4f3-4e41-98ec-123286af90f3" style="">Node object 안에 Node를 정의하는 것은 안된다. 그 이유는 compiler는 하나의 object에 특정 size의 공간을 배정해야 하는데, struct Node{ Node p;};를 하게 되면 p는 Node size를 가지는데, 그 size는 또 Node size를 가지기 때문이다. 따라서, Node 안에 Node object를 정의하고 싶다면 struct Node{ Node* p;}; 형식으로 pointer로 정의해주어야 한다. 그 이유는 pointer는 32/64bit 체제에 따라서 고정된 4/8byte 크기를 가지기 때문이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2fc6b964-3f59-4715-981e-f389e5eadbf8" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-dab4a78e-bcf5-469a-a781-b6b03aeca773" style="">위 IntList1 code에서, Node struct는 IntList 안에서 선언되어있다. 이 Node struct를 nested struct(nested class)라고 한다. 이거의 특징은, nested struct 밖에 있는 것들은(외부는) nested struct의 public만 접근할 수 있다. 따라서 intList1의 모든 method는 Node struct의 public에 있는 field, method만 쓸 수 있는 것이다. 다행이 이 경우 Node는 primative data type이라서 모든 member에 IntList1이 접근할 수 있는 것이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-22ebee64-3c02-4957-b056-80e329bb24a0" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-e08e1eda-3a5c-45c7-bb9a-0fd6ddf2777e" style="">public method가 private helper method에 일을 위임(delegate)한다고 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-52e03109-cbb5-42fe-8862-f8be1ed0703c" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-f2676661-5f09-4b34-a228-84a8fbed55ac" style="">client code는 pointer를 전혀 사용하지 않는다. 또한 Node class도 client에서는 보이지 않는다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d4d8c6ab-aa32-40c8-95ee-883acbcd2a20" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-dcd92a0f-2f21-408a-b656-bc0e949e2e9f" style="">if (p) {...} == if (p !=nullptr) {...}이다! if (!p) {...} == if (p ==nullptr) {...}도 마찬가지다. 그 이유는 nullptr가 0/false로 해석되기 때문이다. 이 사실을 이용해서 for(auto cursor = head; cursor !=nullptr; cursor = head-&gt;next) {std::cout &lt;&lt; cursor.data &lt;&lt; ' ';} 에서 cursor != nullptr를 cursor로 그냥 바꿀 수 있는 것이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3b1083f4-1b32-4816-a2a5-e6bc368a842d" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-d3bf0689-f2ce-4ceb-805c-28ef33d1b791" style="">위 IntList1 linked list class의 경우 총 4개의 public method가 있다. 그 함수들은 바로 length, clear, insert, print가 있다. insert는 tail이 nullptr이라면, head = tail = 새로운 Node(data)하면 되고, nullptr가 아니면 tail-&gt;next = 새로운 Node(data)하면 된다. print()는 for(auto cursor = head; cursor; cursor = cursor-&gt;next) {std::cout &lt;&lt; cursor.data;}하면 된다. length, clear는 recursive 형태로 정의되었다. lengthPrivate(Node *p)은 만약 p == nullptr이면 return 0이고 p != nullptr이면 return 1 + length(p-&gt;next)이다. length 함수는 lengthPrivate만 호출하면 된다. clearPrivate(Node* p)는 clearPrivate(p-&gt;next); delete p;를 하면 되고, clear 함수는 clearPrivate(head);를 하고 head = tail = nullptr;을 해주면 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-633b8e97-a813-4c97-bbbe-c4d306d03e65" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-915edd66-405c-4c1a-9899-d90dc5b09e00" style="">왜 delete를 하고 head = tail = nullptr;와 같이 nullptr을 배정해주는가? 그 이유는 double delete가 undefined behavior이기 때문이다. masked double delete bug이 undefined behavior보다 더 선호되기 때문에 delete하고 nullptr을 가르키는 습관을 기르는 것이 좋은 것이다.(참고: </span><span class="se-fs- se-ff- se-weight-unset" id="SE-26ffae07-3843-43fb-bb28-cf569a7f0267" style=""><a class="se-link" href="https://stackoverflow.com/q/1931126" target="_blank">https://stackoverflow.com/q/1931126</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-2d872f81-bf5d-415b-b960-9a04c04e2071" style="">) 그러나 사실은 사용할 수 있다면 RAII class를 또는 STL을 사용하거나, delete하고 변수의 scope를 끝내는(지역 변수로 사용) 것이 좋다. 그렇지만 이렇게 하지 못하는 경우 항상 포인터는 delete 후 nullptr를 대입해주는 것이 좋다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5bc0daec-65d2-4223-8168-e8047599d8bf" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-4e0f7455-1026-4605-8eb3-09dec5a4b2e7" style="">사실 length나 clear를 recursive하게 정의하는 것이 효율적이지는 않다. 함수 호출이 비용이 많이 들어가는 작업이기 때문이다. 따라서 iterative 하게 정의하게 되면, length는 len 지역변수 하나 만들어서 cursor-&gt;next가 nullptr가 아닐 때까지 for loop 돌리고 nullptr가 아니면 len++하고 len return하면 된다. clear는 cursor가 nullptr가 아닐 때까지 for loop 돌려서 temp = cursor; cursor = cursor-&gt;next; delete temp;하면 된다. 그 다음 head = tail = nullptr까지 하면 된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a733efe5-03c1-46ca-bf53-7831f3a45996" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-6dd74e09-9457-4518-ac4b-6a714fcef1d6" style="">만약 length의 정보를 굉장히 많이 접근해야 하고, 굉장히 큰 list들을 가지고 있거나, list 객체를 별로 만들지 않을 때, length 정보를 담고 있는 member 변수를 class에 추가할 수 있다. 그냥 하나의 정수가 추가되는 것은 좋은 tradeoff이기 때문이다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4e0e7bbe-256b-4ef0-8042-729150cf7a3a" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-b60c215c-2f6e-4933-90b6-92b40f40d00a" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4cb5c6d6-33b5-40a4-b0ec-0cfba4097f09" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-69f47b30-0af1-432f-af4d-dc06db737b8d" style="">destructor</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c69dd2e7-cf75-41e6-9786-f1c6a953a391" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-0c67d7a7-ebc5-48d7-b2eb-b727138c859e" style="">void f() {IntList1 myList; myList.insert(3);}의 함수가 있다고 하자. main함수에서 f()를 호출할 때 memory leak이 발생한다. 왜냐하면 myList는 지역변수인데, head와 tail이 접근할 수 있는 메모리가 scope 밖으로 나가면 더이상 접근할 수 없기 때문이다. 따라서 destructor에서 this-&gt;clear();를 해 줘야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-6a4a8529-a630-49a5-98db-58f40fb2cf37" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-cac68e46-18c8-4007-99e7-ba6f8b546f1d" style="">생성자는 new 명령어에서 호출된다. 또한 destructor는 delete 명령어에서 호출된다. 따라서 IntList1 *p;에서는 생성자가 호출이 되지 않는다. p = new IntList1; delete p;해야 생성자/파멸자가 호출되는 것이다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-70a9a66f-fe7f-4341-a0f4-6c9c88d5d8e9" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-5d72c6cf-f11d-4f39-9c70-f5176ce64aab" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-14b3c704-a3a5-4887-9850-78c25b617c01" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-b071457e-7ea9-42fb-944d-77b8ea50553d" style="">copy constructor, assignment operator</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-232a95c4-5fad-4963-9cff-cd4cbe973598" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-cda3bd23-3754-4a9c-a351-da0194d9647c" style="">IntList1 seq1, seq2; seq1 = seq2; 를 하면 어떤 일이 벌어질까? seq2.head가 seq1.head로, seq2.tail가 seq1.tail로, seq2.len이 seq1.len으로 각각의 메모리 주소가 복사된다. 이렇게 되면 3개의 undesirable result가 만들어진다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0f9f7d39-9bb5-446f-9d42-cb25d3390ed6" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-62eb407e-d911-4463-82e3-9ab96f23f24e" style="">1. aliasing: seq1을 수정하면 seq2도 수정된다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-91d004fa-2dd5-49cc-85df-3929a88b4a36" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-5a646e65-ea59-4952-8fb3-20e2fe5bdf0d" style="">2. memory leak: seq1의 list가 더이상 접근이 불가능하다. seq1의 node를 delete할 수 있는 방법이 없다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7f437fa9-ffa4-4296-a9d3-3f4ed52d806b" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c32fb0da-9794-45b6-8fb8-dec91a469805" style="">3. memory corruption: 보통 생성자의 호출 순서는 파멸자의 호출 순서와 다른다. 만약 seq1을 seq2보다 생성을 먼저 했으면, destructor는 seq2가 먼저 호출이 된다. 그러나 seq1과 seq2는 같은 객체를 가르키고 있으므로 double delete가 되어서 undefined behavior가 되고, 보통 UB는 memory corruption을 일으킨다. 그래서 seq1 = seq2;를 하게 되면 몇몇의 실행에서는 program이 crash한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2a1f15c6-ac70-4a5a-90bb-7b7f38457a3c" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-5035aecc-31f0-42f0-854d-ec75c5e2f159" style="">이를 해결할 수 있는 방법이 있다. 먼저 initialization과 assignment를 구별해야 한다. int x = 3;은 선언과 정의가 동시에 된 문장이다. int x; x = 3;은 선언과 정의가 분리된 문장이다. 선언과 정의가 같이 될 때 그 선언을 initialization라고 한다. 그러나 선언과 정의가 구분되었을 때 정의를 assignment라고 한다. int x{3};은 int x = 3;과 같다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-fd1d488e-debb-498a-9360-2743f7ca442c" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-00ab7dc8-ca61-4da3-9673-5c2fbb1b1cd8" style="">initialization을 copy constructor(X(const X&amp; other))로 할 수 있다. assignment는 X&amp; operator=(const X&amp; other)로 할 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-429fb68b-b298-42bd-a7ca-a99e7dffc0bb" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-4666df23-9ae6-4798-92ad-1c539b746fb1" style="">copy constructor와 assignment operator의 차이는 copy constructor는 non-preexisting object로 시작한다는 것이다. 따라서 preexisting list of node를 청소할 필요가 없다. 그러나 non-preexisiting object로 시작하기 때문에 initialization list로 자신의 생성자를 호출해주어야 한다. 반면 assignment operator는 preexisting object에서 시작하기 때문에 반드시 왼쪽 객체(*this)가 delete되도록 보장해주어야 한다. copy constructor와 assignment operator의 문법은 아래와 같다.</span></p></li></ul><!-- } SE-TEXT -->
</div>
</div>
</div>
</div> <div class="se-component se-code se-l-code_black" id="SE-5624daa5-ff64-4101-bb2d-7b7978b38b8b">
<div class="se-component-content">
<div class="se-section se-section-code se-l-code_black">
<div class="se-module se-module-code se-fs-fs13">
<div class="se-code-source">
<div class="__se_code_view language-javascript">#include &lt;utility&gt;
	// IntList1 copy constructor and assignment operator
	IntList1(const IntList1&amp; list) : IntList1() {
		for (auto cursor = list.head; cursor; cursor = cursor-&gt;next) {
			insert(cursor-&gt;data);
		}
	}
	IntList1&amp; operator=(const IntList1&amp; list) {
		IntList1 tempList(list);
		std::swap(head, tempList.head);
		std::swap(tail, tempList.tail);
		return *this;
	}</div>
</div>
</div>
</div>
</div>
<script class="__se_module_data" data-module='{"type":"v2_code", "id" : "SE-5624daa5-ff64-4101-bb2d-7b7978b38b8b"}' type="text/data"></script>
</div> <div class="se-component se-text se-l-default" id="SE-61f18bbc-dd13-43e8-afad-6356f14473dd">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<!-- SE-TEXT { --><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-640a1bc5-f808-4125-bcc8-01aab5e19953" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-09459cab-662d-4632-ba49-5ed3f7b5f133" style="">operator= overloading에서 어떻게 tempList의 private에 this의 member function이 접근할 수 있을까? 그 이유는 access specifier는 class마다 효과있는 것이지, object마다에게 효과있는 것이 아니다. 따라서 같은 class라면 member function은 local class의 모든 member에 접근 가능한 것이다.(참고: </span><span class="se-fs- se-ff- se-weight-unset" id="SE-508969ba-43ad-46cf-94b1-50005461d939" style=""><a class="se-link" href="https://stackoverflow.com/a/48861580" target="_blank">https://stackoverflow.com/a/48861580</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-70e6f18f-b83f-4f59-b248-711521198ca8" style="">)</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d713c71f-26dd-42d9-829d-6080d6d13ee3" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-135c8550-6e8d-4564-b890-8d35e47156fa" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-eb4d2ccc-129e-4bdc-bd46-946117854b5a" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-d9af920f-ec5a-40f8-a00d-aaaee8e7fbe7" style="">Rule of three</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-621c7ffd-6dd5-4d4b-bc5c-aa6f006cdbf4" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-a345459d-8b30-4f7a-85f5-5eb1dc2b3f41" style="">copy constructor, assignment operator, destructor 중 적어도 하나가 필요하다고 class designer가 생각한다면, class designer는 이 3가지를 모두 구현해야 한다. 이 세가지를 모두 한번에 정의해야 하는 이유는 위에 다 정리되어 있다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-4d091748-4d57-4a95-a54d-bc44fc9281f7" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-fab1bbe5-63a9-4cd5-8959-c19939e963ba" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-fb16b9d1-e9e3-41eb-ac82-283b63e90f9f" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-cac8a4f8-1212-4fcb-8ff7-f1bb42f7187a" style="">Rvalue reference</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2095b26a-80e2-4279-bfb9-7aa4bb2fe4d3" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-31cacd22-cf2b-485d-b6cc-3bf79fea3c7f" style="">rvalue란 assignment operator 오른쪽에 나타나는 값이다. rvalue는 assignment operator 왼쪽에 나타날 수 없다. 반면 lvalue는 assignment operator 왼쪽, 오른쪽에 나타날 수 있고, 혼자 나타날 수 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5277552d-1814-445a-b276-35dcef5a5e30" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-ee458508-81c1-4c9b-ba67-f2982c9020a7" style="">rvalue는 temporary value다. temporary value의 뜻은 자기 문장이 실행될 때에만 뜻이 있는 값이다. 실행 프로그램은 rvalue의 computation 결과를 메모리에 일시적으로 저장하지만, 프로그램은 보통 그 메모리를 reference하지 못한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c40b3a61-ab0b-4987-a453-6ec4f6437948" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-f2c9d203-46e0-4581-9621-5c9925f13c03" style="">따라서 int&amp; r = x+3;은 불가능하다. 그 이유는 temporary value를 reference variable에 배정할 수 없게 c++가 만들어 놓았기 때문이다. 왜냐하면 r은 x+3 값의 주소를 갖는데, x+3은 그 문장 이후에는 존재하지 않는다. 따라서 temporary value인 rvalue는 reference할 수 없다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-42facb61-7eb9-4fc2-8f14-8862567e2c6a" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-b7f629d2-d110-4756-b7a0-37d2709d81bc" style="">그러나 const int&amp; cr = x+3;은 가능하다. 이 값은 scope에서 벗어날 떄까지 cr이 referencd하는 공간에 일시적인 값 x+3을 저장한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-199a941c-c2a5-4bcb-b03c-933bc731bf68" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-434bcde1-bf0f-4c40-956a-8bb25205fb9b" style="">따라서  int g(int&amp;n){return 10 * n}에서 g(x+2);는 불가능하지만  int g(const int&amp;n){return 10 * n}에서 g(x+2);는 가능하다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-b6474bde-af60-4a9b-bea4-1bd077bbb2f8" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-3f2677fa-a4b7-4d2a-8d1b-d075cf557cfd" style="">const int&amp; n = x+3;은 temporary value를 copy를 한번 하고 n에 보낸다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f91cbefb-ba01-45cf-b6d6-acd34c389cc1" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-cdee3b2a-6cfd-4e84-9b39-cfd86f1026de" style="">따라서 만약 copy constructor가 있다고 하고, list object를 return하는 함수 g가 있다고 했을 때, IntList1 list = g();를 하게 되면, list의 copy constructor를 호출하게 되고, 이 과정에서 g()는 assignment의 왼쪽에 갈 수 없으므로 rvalue이기 때문에, rvalue의 값을 const IntList reference 변수에 전달하기 위해서는 복사를 한번 하고 보내준다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ef63a5b0-66ed-461a-8472-f9a5d70d0979" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-8f04dbaa-4b8e-4c15-a495-b3662747a3cd" style="">만약 list가 수천개의 node를 가지고 있을 때 이 복사는 cost가 매우 높을 것이다. 따라서 이를 방지하기 위해 rvalue reference가 있다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5942b3ce-e266-4640-a342-91b597630ec1" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-647614c6-0242-4989-b860-1425390a5279" style="">rvalue reference는 int&amp;&amp; r = x+3;이다. 이거는 temporary value를 복사 없이 alias할 수 있도록 만들어준다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-90e36275-64a5-4877-be36-4b45739f9326" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-ebad4057-38e1-4e45-8af7-f4c5c7943dea" style="">이거를 constructor, assignment operator에 추가해 보자. rvalue reference로 인수를 받는 constructor, assignment operator를 각각 move constructor, move assignment operator라고 부르겠다. 그러면 문법은 다음과 같다. IntList1(IntList&amp;&amp; list); IntList&amp; operator=(IntList&amp;&amp; list);</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5ff88beb-6849-43e4-ab07-afadaa4e996c" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-341ca0fe-27f2-46a4-97aa-d7a64a424455" style="">move constructor, move assignment operator의 구현 내용은 아래와 같다</span></p></li></ul><!-- } SE-TEXT -->
</div>
</div>
</div>
</div> <div class="se-component se-code se-l-code_black" id="SE-95d0ab5d-0890-466b-bb14-1f088261855f">
<div class="se-component-content">
<div class="se-section se-section-code se-l-code_black">
<div class="se-module se-module-code se-fs-fs13">
<div class="se-code-source">
<div class="__se_code_view language-javascript">	IntList1(IntList1&amp;&amp; list) : IntList1() {
		std::swap(head, list.head);
		std::swap(tail, list.tail);
	}
	IntList1&amp; operator=(IntList1&amp;&amp; list) {
		std::swap(head, list.head);
		std::swap(tail, list.tail);
		return *this;
	}</div>
</div>
</div>
</div>
</div>
<script class="__se_module_data" data-module='{"type":"v2_code", "id" : "SE-95d0ab5d-0890-466b-bb14-1f088261855f"}' type="text/data"></script>
</div> <div class="se-component se-text se-l-default" id="SE-b01aef04-6c85-46a4-b645-bdad6ffc84bd">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<!-- SE-TEXT { --><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2ae030e0-02c1-45e0-99c3-a5b6cb0e30d2" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-74f3b54d-7fcc-4e7b-89b4-932d1e40c53c" style="">이렇게 구현할 수 있는 이유는 list가 지역 변수이기 때문이다. 이 함수가 끝나면 list는 destructor에 의해 파괴되는데(destructor가 호출되는 시기는 delete이거나 scope 벗어나는 경우), 그렇기 때문에 그냥 swap만 해주면 된다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-5eeb48c4-7bf7-4d34-9799-1f1a16ff91d6" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-7c40bc7c-123d-450c-a291-8c10d9ac91cc" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-0e8cf2dd-1cff-4497-985e-a469544b251a" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-bb9f9680-5aae-41fa-bd17-2e4394fac9b7" style="">c++ Rule of five</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-60ca98d4-b5d7-4598-9f98-ba097570a11d" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-df48e2a5-f496-43a7-99dc-359765d96dc7" style="">copy construction, move construction, destruction, copy assignment, move assignment를 모두 정의하지 않으면 compiler가 value sementics를 support하는 default version을 자동으로 만들어 놓는다. </span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-81163a6b-72b6-4ffb-9d51-397ce0f9a3e2" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-740974df-349b-479a-9381-a8d2378d3013" style="">(value sementics: 서로 다른 이름을 가진 변수 2개는 서로 다른 객체를 가르킨다. reference sementics: value sementics와 반대, pointer와 reference가 referencd sementics에 포함된다. 즉 여기서 value sementics를 support하는 default version의 함수들을 만들어 놓는다는 것은 pointer나 reference 변수가 아닌 일반 변수를 data member로 가졌을 경우 아무 문제 없이 동작하도록 지원된다는 뜻이다.)</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-bf264287-96e7-4fde-8a02-a9914fb675f0" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-dae32c00-8ffc-4a28-9082-bf87c2b55f14" style="">그러나 destructor, copy constructor, copy assignment operator 중 하나를 프로그래머가 정의하게 되면, compiler는 자동으로 move constructor 또는 move assignment operator를 만들지 않는다. 이거는 사실 구현을 안해도 된다. 왜냐하면 구현을 안하면 copy constructor의 경우 rvalue를 인수로 받았다고 했을 때 temporary value가 copy constructor에 의해 한번 복사가 된 후, copy constructor가 실행된다는 것이다. copy assignment의 경우도 temporary value가 copy assignment에 의해 복사가 되고 다시 copy assignment가 실행된다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-bed955b0-0cd6-4314-9316-b51f56a3fac3" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-8f9a35e8-3a4f-4e9a-bf83-d73735f6c8c6" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ee98de87-63fb-4549-afb9-b2aff45adc86" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-5302f9a1-2ef6-4de4-920a-76f6d216acb9" style="">explicit하게 copy construction, move construction, destruction, copy assignment, move assignment를 정의하는 방법</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-e710f117-d9e7-41c5-9d6e-8318e0e36d70" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-e55325ef-334c-4aa8-b24a-af5ad55875fe" style="">IntList() = default;</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-479f9660-df73-4f3e-95ec-d37d17318d1a" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-68ba024a-d2bd-474e-a492-c6358074d69e" style="">IntList1(int x){}</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-9fa286ee-217d-4154-ab0b-a33c6fedc1b3" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-799be29d-6856-4413-87b4-25c9b51f455d" style="">모든 copy construction, move construction, destruction, copy assignment, move assignment에 = default 또는 delete 붙일 수 있음. IntList() = delete;</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a8e1a315-927f-423b-a501-f751fe85df9c" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-76ebec26-8bd0-4626-ad82-556022e6a521" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-d00bfecc-9fc5-4cc2-869f-578d09fd00b2" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-e8c13b7b-0d83-48e4-aa75-dec389bebbc5" style="">smart pointer (#include &lt;memory&gt;)</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-31c99b4c-3d7a-4f3c-8996-f4b16b418412" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-d6ecbdd1-000c-4052-9583-f3e581ce5358" style="">문법: std::shared_ptr&lt;class&gt; p = std::make_shared&lt;class&gt;(12);</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-cbef84e5-c1b5-4465-b89f-ed3aa34458db" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-b4b8ba5d-8e6c-45e9-8bf9-0dde0ec0937b" style="">auto p = std::make_shared&lt;class&gt;(12);</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-a72df00c-dd61-410d-bd7b-202bc703de1b" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-54f2e161-9b0f-4e57-a41e-41cb855c4d7c" style="">p = nullptr;하면 destructor가 호출됨. 그 이유는 std::shared_ptr의 생성자 또는 std::make_shared 함수를 통해 동적으로 생성된 객체는 reference count라는 것을 가지고 있다. 예를 들어 std::shared_ptr 변수 3개가 같은 객체를 가르키고 있다면, 그 reference count는 3이 된다. 그러나 p = nullptr; q = std::make_shared&lt;class&gt;(12); r = nullptr;을 하게 되면 그 reference count는 0이 되어서 객체의 destructor가 호출된다.</span></p></li></ul><p class="se-text-paragraph se-text-paragraph-align-" id="SE-f5e80c3f-d245-4045-bab8-27f4266bcfc5" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-2a906932-1f4a-4df8-83f9-02b8b614b22c" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-1704a25e-991f-4db0-8882-b78883da2621" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-0b1b2609-4cd6-4b1a-9d6f-1222df109263" style="">placement new</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-8cdcc365-276a-466c-96f9-ce16bf79c72d" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-acdf8485-5541-4db0-a1b2-f845b830e4ce" style="">primitive type의 경우 그냥 int* p = new int[10];하면 되었다. 그러나 사용자 정의형 type의 경우 내가 원하는 생성자를 호출하고 싶을 떄가 있다. 내가 원하는 생성자를 배열 안에 호출하고 싶다는 것이다. 그럴 경우:</span></p></li></ul><!-- } SE-TEXT -->
</div>
</div>
</div>
</div> <div class="se-component se-code se-l-code_black" id="SE-6a26a273-8625-49f5-bf0f-b8a280b9a079">
<div class="se-component-content">
<div class="se-section se-section-code se-l-code_black">
<div class="se-module se-module-code se-fs-fs13">
<div class="se-code-source">
<div class="__se_code_view language-javascript">﻿char* pChar = new char[sizeof(class) * 10];
class* pClass = reinterpret_cast&lt;class*&gt;(pChar);
for (int i = 0;i &lt; 10;i++) { pClass[i] = class(i,2,3 * i); new (&amp;pClass[i]) class(i);}
for (int i = 0;i &lt; 10;i++) { pClass[i].~class();}
delete [] pChar;</div>
</div>
</div>
</div>
</div>
<script class="__se_module_data" data-module='{"type":"v2_code", "id" : "SE-6a26a273-8625-49f5-bf0f-b8a280b9a079"}' type="text/data"></script>
</div> <div class="se-component se-text se-l-default" id="SE-86e102ca-7a6f-4801-9f88-6e504af106bc">
<div class="se-component-content">
<div class="se-section se-section-text se-l-default">
<div class="se-module se-module-text">
<!-- SE-TEXT { --><p class="se-text-paragraph se-text-paragraph-align-" id="SE-c527fa74-054b-40e6-9877-d510d455e1f3" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-82e76b74-4aed-4de2-b17c-f23834ec48a8" style="">P.S. 뭔소린지 모르겠다. placement new의 경우 교과서에는 없다. 나중에 advanced c++ 배울 떄 그냥 배워야겠다. (참고: </span><span class="se-fs- se-ff- se-weight-unset" id="SE-86e4298c-ebfe-403c-984d-87f40ccf870e" style=""><a class="se-link" href="https://stackoverflow.com/a/4756306" target="_blank">https://stackoverflow.com/a/4756306</a></span><span class="se-fs- se-ff- se-weight-unset" id="SE-dc0bc41c-71b9-49a4-8a99-b46b69f0dc5f" style="">)</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-3693dd2c-1397-441c-bfe0-eb941179bb6d" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-baad2065-6b59-43b4-9c8b-077db0f1f51f" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-979817e6-784c-4052-bcca-9b560759732f" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-4bfd0664-3ab0-466d-9b81-faf51a23b452" style="">​</span></p><p class="se-text-paragraph se-text-paragraph-align-" id="SE-2fa81474-9ce1-4601-b59d-c84d16a4ce5b" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-a383b35e-2071-42bf-81fe-82b88f629a1e" style="">Ch.19. Generic programming</span></p><ul class="se-text-list se-text-list-type-bullet-disc"><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ff0813d3-43dd-4432-83c3-387bc6842af1" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-0640bc63-7625-4368-bbd7-4552df01b153" style="">문법: template &lt;typename T, typename N&gt; 또는 template &lt;class T&gt;. template &lt;typename T, int N&gt; 도 가능. 이때 인수 N은 non-type template parameter이다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-26ccf7b0-b9ce-49b4-a74f-5c80c22e958f" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c0de15a1-7416-45db-86f0-52a2e8bb383f" style="">선언과 정의를 분리할 때, 항상 template &lt;typename T&gt;를 써줘야 하고, class method를 정의 할 때에는 class&lt;T&gt;::method(){} 처럼 써줘야 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-90a66db4-dfad-45f4-be34-fd903bab8c23" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-c170340d-ab3a-44dc-9b16-c89c24fa7dae" style="">compiler가 template function으로부터 실제 함수 정의를 만드는 과정을 template instantiation (템플릿 인스턴스화)라고 한다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-7ba11787-83ec-414c-ab71-720414162e73" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-dfe8c737-d784-4689-9695-14cbe52b0236" style="">예를 들어 template &lt;typename T, int N&gt; T scale(const T&amp; value) {return value * N} 이라는 함수가 있을 때 explicitly instantiate해야 한다. scale&lt;int, 4&gt;(5); 만약 compiler가 자동으로 type을 추측할 수 있다면, 굳이 명시적으로 인스턴스화 할 필요는 없어 보인다. 그러나 어쩔 때는 explicitly instantiate하는게 좋을 수도 있다. 하나의 예를 더 들자면 2개의 T type 인수를 가지는 함수가 있을 때 인수를 둘다 정수를 주거나 둘다 소수점을 주면 아무 문제가 없다. 그러나 2/2.2 이렇게 주면 compiler가 error를 만든다.</span></p></li><li class="se-text-list-item"><p class="se-text-paragraph se-text-paragraph-align-" id="SE-ab6d8715-eb8b-4b22-aef4-92d831d886e4" style=""><span class="se-fs- se-ff- se-weight-unset" id="SE-f8f93037-cec9-4da0-b435-08958996de0e" style="">​</span></p></li></ul><!-- } SE-TEXT -->
</div>
</div>
</div>
</div> </div>
</div>
</div>